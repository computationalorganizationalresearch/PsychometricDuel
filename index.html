

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Validity Wars: Power Protocol ‚Äî Online</title>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<style>
    * { box-sizing: border-box; margin: 0; padding: 0; }

    :root {
        --bg-dark: #0a0a1a;
        --bg-board: #111128;
        --predictor: #2266cc;
        --predictor-light: #4488ee;
        --outcome: #cc2244;
        --outcome-light: #ee4466;
        --spell: #22cc88;
        --trap: #9922cc;
        --resource: #ff9800;
        --meta: #e040fb;
        --gold: #ffcc00;
        --gold-dark: #aa8800;
        --green: #22cc66;
        --white: #e8e8f0;
        --gray: #555577;
    }

    body {
        font-family: 'Press Start 2P', monospace;
        background: #050505;
        color: var(--white);
        overflow: hidden;
        height: 100vh;
        width: 100vw;
        display: flex;
        justify-content: center;
        align-items: center;
        user-select: none;
        touch-action: none;
    }

    #game-container {
        position: relative;
        width: 100vw;
        height: 100vh;
        max-width: calc(100vh * (4/3));
        max-height: calc(100vw * (3/4));
        aspect-ratio: 4 / 3;
        margin: auto;
        background: var(--bg-dark);
        border: 0.4cqmin solid var(--gold-dark);
        box-shadow: 0 0 3cqmin rgba(255, 204, 0, 0.2);
        display: flex;
        flex-direction: column;
        container-type: size;
        overflow: hidden;
    }

    #game-container::after {
        content: ''; position: absolute; inset: 0;
        background: repeating-linear-gradient(0deg, transparent, transparent 0.2cqmin, rgba(0,0,0,0.1) 0.2cqmin, rgba(0,0,0,0.1) 0.4cqmin);
        pointer-events: none; z-index: 9999;
    }

    /* ===== TITLE / LOBBY SCREEN ===== */
    #title-screen {
        position: absolute; inset: 0; background: var(--bg-dark);
        display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 1000;
    }
    #title-screen h1 {
        font-size: 5cqmin; color: var(--gold); text-align: center;
        text-shadow: 0.5cqmin 0.5cqmin 0 #aa4400, 0 0 2cqmin rgba(255,200,0,0.4);
        margin-bottom: 2cqmin; animation: titlePulse 2s ease-in-out infinite;
    }
    #title-screen h2 { font-size: 2cqmin; color: var(--outcome-light); margin-bottom: 3cqmin; text-align: center;}
    @keyframes titlePulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.03); } }

    .start-btn {
        font-family: 'Press Start 2P', monospace; font-size: 2cqmin;
        color: var(--bg-dark); background: var(--gold);
        border: none; padding: 2cqmin 4cqmin; cursor: pointer;
        box-shadow: 0 0.6cqmin 0 var(--gold-dark); transition: all 0.1s;
        margin: 1cqmin;
    }
    .start-btn:hover { transform: translateY(0.2cqmin); box-shadow: 0 0.4cqmin 0 var(--gold-dark); }
    .start-btn:active { transform: translateY(0.6cqmin); box-shadow: none; }
    .start-btn:disabled { opacity: 0.4; cursor: not-allowed; }

    .how-to-btn {
        font-family: 'Press Start 2P', monospace; font-size: 1.2cqmin; color: var(--gold);
        background: transparent; border: 0.3cqmin solid var(--gold);
        padding: 1cqmin 2cqmin; cursor: pointer; margin-top: 2cqmin;
    }

    .lobby-section {
        display: flex; flex-direction: column; align-items: center; gap: 1.5cqmin;
        margin-top: 2cqmin;
    }
    .lobby-row { display: flex; align-items: center; gap: 1cqmin; }
    .lobby-input {
        font-family: 'Press Start 2P', monospace; font-size: 1.8cqmin;
        background: #111; color: var(--gold); border: 0.3cqmin solid var(--gold-dark);
        padding: 1cqmin 1.5cqmin; text-align: center; width: 22cqmin;
        letter-spacing: 0.3cqmin; text-transform: uppercase;
    }
    .lobby-input::placeholder { color: var(--gray); font-size: 1.2cqmin; }
    .lobby-status {
        font-size: 1.2cqmin; color: var(--predictor-light);
        text-align: center; min-height: 2cqmin; animation: blink 1.5s step-end infinite;
    }
    .lobby-code-display {
        font-size: 2.5cqmin; color: var(--gold); letter-spacing: 0.4cqmin;
        background: #0d0d22; border: 0.3cqmin solid var(--gold);
        padding: 1.5cqmin 3cqmin; cursor: pointer;
    }
    .lobby-code-display:hover::after { content: ' (click to copy)'; font-size: 1cqmin; color: var(--gray); }
    .lobby-or { font-size: 1cqmin; color: var(--gray); margin: 1cqmin 0; }
    .menu-subtitle {
        font-size: 1.1cqmin; color: var(--gray); letter-spacing: 0.12cqmin;
        text-align: center; margin-bottom: 0.5cqmin;
    }
    .difficulty-grid {
        display: grid; grid-template-columns: 1fr 1fr; gap: 1cqmin;
        width: min(56cqmin, 90%);
    }
    .difficulty-btn {
        font-family: 'Press Start 2P', monospace;
        font-size: 1cqmin;
        color: var(--gold);
        background: #111;
        border: 0.25cqmin solid var(--gold-dark);
        padding: 1.2cqmin 1cqmin;
        cursor: pointer;
        text-align: center;
    }
    .difficulty-btn:hover { border-color: var(--gold); }
    .difficulty-btn.active {
        background: rgba(255,204,0,0.14);
        border-color: var(--gold);
        box-shadow: 0 0 0.8cqmin rgba(255,204,0,0.35);
    }
    #ai-difficulty-desc {
        min-height: 3.6cqmin;
        line-height: 1.4;
        max-width: 62cqmin;
        animation: none;
        color: var(--white);
    }

    /* ===== TUTORIAL / MULLIGAN MODALS ===== */
    .modal-overlay {
        position: absolute; inset: 0; background: rgba(0,0,0,0.9);
        display: none; align-items: center; justify-content: center;
        z-index: 2000; padding: 4cqmin;
    }
    .modal-overlay.active { display: flex; }
    .modal-box {
        background: #1a1a3a; border: 0.4cqmin solid var(--gold); padding: 3cqmin;
        max-width: 90%; max-height: 90%; overflow-y: auto; line-height: 1.8; font-size: 1.5cqmin;
    }
    .modal-box h2 { color: var(--gold); font-size: 2.5cqmin; margin-bottom: 2cqmin; }
    .modal-box h3 { color: var(--predictor-light); font-size: 1.8cqmin; margin: 2cqmin 0 1cqmin; }

    #card-gallery-modal .modal-box {
        width: min(120cqmin, 96%);
        max-width: none;
        background: linear-gradient(180deg, #121233, #0a0a1f 55%);
        border-color: var(--gold-dark);
        box-shadow: inset 0 0 0 0.2cqmin rgba(255,204,0,0.2);
    }
    .gallery-header {
        display: flex;
        justify-content: space-between;
        align-items: baseline;
        gap: 1cqmin;
        margin-bottom: 1.5cqmin;
    }
    .gallery-subtitle {
        color: var(--gray);
        font-size: 1cqmin;
        line-height: 1.5;
    }
    .gallery-scroll {
        max-height: min(64vh, 62cqmin);
        overflow-y: auto;
        padding-right: 0.8cqmin;
    }
    .gallery-section { margin-bottom: 2.2cqmin; }
    .gallery-section-title {
        font-size: 1.2cqmin;
        color: var(--gold);
        border-bottom: 0.12cqmin solid rgba(255,204,0,0.4);
        padding-bottom: 0.6cqmin;
        margin-bottom: 1cqmin;
    }
    .gallery-cards-row {
        display: flex;
        gap: 0.8cqmin;
        overflow-x: auto;
        padding-bottom: 0.8cqmin;
    }
    .gallery-card {
        width: 10.4cqmin;
        min-height: 14.6cqmin;
        border: 0.18cqmin solid;
        padding: 0.55cqmin;
        background: #171733;
        display: flex;
        flex-direction: column;
        flex-shrink: 0;
        cursor: pointer;
        transition: transform 0.12s ease, box-shadow 0.12s ease;
    }
    .gallery-card:hover {
        transform: translateY(-0.3cqmin);
        box-shadow: 0 0 1cqmin rgba(255,255,255,0.25);
    }
    .gallery-card.predictor { border-color: var(--predictor); }
    .gallery-card.outcome { border-color: var(--outcome); }
    .gallery-card.monster { border-color: var(--gold); background: linear-gradient(140deg, #1c1c39, #2a1a3a); }
    .gallery-card.spell { border-color: var(--spell); background: #0a1f14; }
    .gallery-card.trap { border-color: var(--trap); background: #1a0a1f; }
    .gallery-card.meta { border-color: var(--meta); background: linear-gradient(140deg, #2d0836, #1a0420); }
    .gallery-badge {
        font-size: 0.62cqmin;
        color: #fff;
        text-align: center;
        padding: 0.2cqmin;
        margin-bottom: 0.35cqmin;
        letter-spacing: 0.04cqmin;
    }
    .gallery-card.predictor .gallery-badge { background: var(--predictor); }
    .gallery-card.outcome .gallery-badge { background: var(--outcome); }
    .gallery-card.monster .gallery-badge { background: var(--gold-dark); }
    .gallery-card.spell .gallery-badge { background: var(--spell); }
    .gallery-card.trap .gallery-badge { background: var(--trap); }
    .gallery-card.meta .gallery-badge { background: var(--meta); }
    .gallery-name {
        color: var(--gold);
        font-size: 0.76cqmin;
        text-align: center;
        line-height: 1.4;
        margin-bottom: 0.35cqmin;
        min-height: 2.1cqmin;
    }
    .gallery-icon {
        flex: 1;
        min-height: 3cqmin;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 2.1cqmin;
    }
    .gallery-copy {
        margin-top: 0.45cqmin;
        border-top: 0.1cqmin solid rgba(255,255,255,0.14);
        padding-top: 0.4cqmin;
        font-size: 0.58cqmin;
        line-height: 1.4;
        color: #d8d8e3;
        min-height: 3.4cqmin;
        text-align: center;
    }
    .gallery-reliability,
    .gallery-zoom-reliability {
        margin-top: 0.35cqmin;
        text-align: center;
        color: var(--gold);
        font-size: 0.56cqmin;
    }
    .gallery-zoom-reliability {
        margin-top: 0.9cqmin;
        font-size: 0.95cqmin;
    }
    .gallery-pair-table {
        width: 100%;
        margin-top: 0.3cqmin;
        border-collapse: collapse;
        font-size: 0.5cqmin;
        line-height: 1.25;
    }
    .gallery-pair-table.zoom {
        margin-top: 0.8cqmin;
        font-size: 0.86cqmin;
    }
    .gallery-pair-table th,
    .gallery-pair-table td {
        border: 0.08cqmin solid rgba(255,255,255,0.2);
        padding: 0.12cqmin 0.16cqmin;
        text-align: center;
    }
    .gallery-pair-table th {
        color: var(--gold);
        font-weight: normal;
    }
    .gallery-zoom-overlay {
        position: absolute;
        inset: 0;
        background: rgba(0,0,0,0.78);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 2600;
        padding: 2cqmin;
    }
    .gallery-zoom-overlay.active { display: flex; }
    .gallery-zoom-card {
        width: min(46cqmin, 96%);
        max-height: 90%;
        overflow-y: auto;
        border: 0.3cqmin solid;
        padding: 1.3cqmin;
        background: #171733;
        box-shadow: 0 0 2.2cqmin rgba(0,0,0,0.65);
    }
    .gallery-zoom-overlay.predictor .gallery-zoom-card { border-color: var(--predictor); }
    .gallery-zoom-overlay.outcome .gallery-zoom-card { border-color: var(--outcome); }
    .gallery-zoom-overlay.monster .gallery-zoom-card { border-color: var(--gold); background: linear-gradient(140deg, #1c1c39, #2a1a3a); }
    .gallery-zoom-overlay.spell .gallery-zoom-card { border-color: var(--spell); background: #0a1f14; }
    .gallery-zoom-overlay.trap .gallery-zoom-card { border-color: var(--trap); background: #1a0a1f; }
    .gallery-zoom-overlay.meta .gallery-zoom-card { border-color: var(--meta); background: linear-gradient(140deg, #2d0836, #1a0420); }
    .gallery-zoom-close {
        position: absolute;
        top: 2cqmin;
        right: 2cqmin;
        font-family: 'Press Start 2P', monospace;
        font-size: 1cqmin;
        border: 0.2cqmin solid var(--gold);
        background: rgba(10,10,26,0.95);
        color: var(--gold);
        padding: 0.8cqmin 1.1cqmin;
        cursor: pointer;
    }
    .gallery-zoom-title { font-size: 1.6cqmin; margin-bottom: 1.2cqmin; color: var(--gold); text-align: center; }
    .gallery-zoom-icon { font-size: 8cqmin; text-align: center; line-height: 1; margin: 0.8cqmin 0 1cqmin; }
    .gallery-zoom-copy {
        margin-top: 1.2cqmin;
        border-top: 0.12cqmin solid rgba(255,255,255,0.2);
        padding-top: 1cqmin;
        font-size: 1cqmin;
        line-height: 1.7;
        text-align: center;
    }

    /* ===== GAME SCREEN ===== */
    #game-screen { display: none; height: 100%; flex-direction: column; width: 100%; position: relative; }
    #game-screen.active { display: flex; }

    .persistent-help-link {
        position: absolute;
        top: 8.8%;
        right: 1.2cqmin;
        z-index: 120;
        font-family: 'Press Start 2P', monospace;
        font-size: 0.95cqmin;
        color: var(--gold);
        background: rgba(10,10,26,0.55);
        border: 0.18cqmin solid rgba(255,204,0,0.35);
        padding: 0.6cqmin 1cqmin;
        cursor: pointer;
        opacity: 0.62;
        transition: opacity 0.12s, border-color 0.12s, background 0.12s;
    }
    .persistent-help-link:hover {
        opacity: 1;
        border-color: var(--gold);
        background: rgba(10,10,26,0.9);
    }

    #mulligan-modal .modal-box {
        width: min(115cqmin, 96%);
        max-width: none;
    }
    .mulligan-grid {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 1cqmin;
        margin-top: 1.5cqmin;
    }
    .mulligan-card-wrap {
        position: relative;
        padding: 0.3cqmin;
        border: 0.2cqmin solid transparent;
        background: rgba(255,255,255,0.02);
        cursor: pointer;
    }
    .mulligan-card-wrap.selected {
        border-color: var(--outcome-light);
        background: rgba(204,34,68,0.12);
        box-shadow: 0 0 1cqmin rgba(238,68,102,0.22);
    }
    .mulligan-card-wrap::after {
        content: 'REPLACE';
        position: absolute;
        left: 50%;
        bottom: -1.2cqmin;
        transform: translateX(-50%);
        font-size: 0.75cqmin;
        color: var(--outcome-light);
        opacity: 0;
        pointer-events: none;
    }
    .mulligan-card-wrap.selected::after { opacity: 1; }
    .mulligan-subtext {
        color: var(--gray);
        font-size: 1.1cqmin;
        line-height: 1.6;
        margin-top: 0.8cqmin;
    }

    .top-bar {
        display: flex; justify-content: space-between; align-items: center;
        padding: 0 2cqmin; background: #0d0d22; border-bottom: 0.3cqmin solid var(--gray);
        height: 8%; width: 100%; flex-shrink: 0;
    }
    .lp-display { display: flex; align-items: center; gap: 1cqmin; font-size: 1.5cqmin; }
    .lp-bar { width: 15cqmin; height: 1.5cqmin; background: #222; border: 0.2cqmin solid var(--gray); position: relative; }
    .lp-fill { height: 100%; background: var(--green); transition: width 0.5s; }
    .lp-label { font-size: 1.2cqmin; color: var(--gray); }
    .lp-value { font-size: 1.5cqmin; color: var(--gold); min-width: 6cqmin; text-align: right; }
    .turn-indicator { font-size: 1.2cqmin; color: var(--gold); padding: 0.8cqmin 1.5cqmin; border: 0.2cqmin solid var(--gold); animation: blink 1.5s step-end infinite; }

    .game-board {
        height: 62%; width: 100%; flex-shrink: 0;
        display: flex; flex-direction: column;
        padding: 0.5cqmin 2cqmin; gap: 0.2cqmin;
    }
    .field-row { display: flex; gap: 0.8cqmin; justify-content: center; align-items: center; flex: 1; min-height: 0;}
    .field-label { font-size: 0.8cqmin; color: var(--gray); writing-mode: vertical-rl; padding: 0 0.5cqmin; }
    .field-divider { height: 0.2cqmin; width: 100%; background: linear-gradient(90deg, transparent, var(--gray), transparent); margin: 0.2cqmin 0; flex-shrink: 0;}

    .card-slot {
        width: 7.5cqmin; height: 10cqmin; border: 0.2cqmin dashed rgba(255,255,255,0.15);
        display: flex; align-items: center; justify-content: center; position: relative;
    }
    .card {
        width: 7.5cqmin; height: 10cqmin; border: 0.2cqmin solid; padding: 0.4cqmin;
        display: flex; flex-direction: column; cursor: pointer; position: relative;
        transition: transform 0.1s; background: #1a1a2e; flex-shrink: 0;
    }
    .monster-card {
        width: 7.5cqmin; height: 10cqmin; border: 0.2cqmin solid var(--gold); padding: 0.4cqmin;
        background: linear-gradient(135deg, #1a1a3a, #2a1a3a);
        display: flex; flex-direction: column; position: relative; cursor: pointer;
        box-shadow: 0 0 1cqmin rgba(255,204,0,0.2); flex-shrink: 0;
    }
    .monster-card.is-meta {
        border: 0.3cqmin solid var(--meta);
        box-shadow: 0 0 2cqmin var(--meta);
        background: linear-gradient(135deg, #2a002a, #4a004a);
    }

    .opponent-side .card-slot, .opponent-side .card, .opponent-side .monster-card { width: 6cqmin; height: 8cqmin; }
    .opponent-side .card-type-badge { font-size: 0.4cqmin; }
    .opponent-side .card-construct { font-size: 0.6cqmin; }
    .opponent-side .card-indicator { font-size: 0.5cqmin; }
    .opponent-side .monster-sprite { font-size: 2cqmin; }
    .opponent-side .monster-stats-bar { font-size: 0.6cqmin; }
    .opponent-side .monster-reliability { font-size: 0.5cqmin; }

    .card:hover { transform: translateY(-0.5cqmin); z-index: 10; }
    .card.selected { transform: translateY(-1cqmin); box-shadow: 0 0 1.5cqmin var(--gold); border-color: var(--gold) !important; }
    .card.predictor { border-color: var(--predictor); }
    .card.outcome { border-color: var(--outcome); }
    .card.spell { border-color: var(--spell); background: #0a1f14; }
    .card.trap { border-color: var(--trap); background: #1a0a1f; }
    .card.resource { border-color: var(--resource); background: #331a00; }

    .card-type-badge { font-size: 0.6cqmin; padding: 0.2cqmin; color: #fff; text-align: center; margin-bottom: 0.2cqmin; }
    .card.predictor .card-type-badge { background: var(--predictor); }
    .card.outcome .card-type-badge { background: var(--outcome); }
    .card.spell .card-type-badge { background: var(--spell); }
    .card.trap .card-type-badge { background: var(--trap); }
    .card.resource .card-type-badge { background: var(--resource); }

    .card-construct { font-size: 0.8cqmin; color: var(--gold); text-align: center; margin-bottom: 0.2cqmin; line-height: 1.2; }
    .card-indicator { font-size: 0.7cqmin; color: var(--white); text-align: center; flex: 1; display: flex; align-items: center; justify-content: center; }
    .card-stats { display: flex; justify-content: space-between; font-size: 0.6cqmin; border-top: 0.1cqmin solid rgba(255,255,255,0.15); padding-top: 0.2cqmin; }

    .monster-name { font-size: 0.6cqmin; color: var(--gold); text-align: center; margin-bottom: 0.2cqmin; line-height: 1.2; }
    .monster-sprite { flex: 1; display: flex; align-items: center; justify-content: center; font-size: 2.8cqmin; }
    .monster-stats-bar {
        display: flex; justify-content: space-between;
        font-size: 0.8cqmin; border-top: 0.1cqmin solid var(--gold-dark);
        padding-top: 0.2cqmin; color: #ff6644;
    }
    .monster-reliability { font-size: 0.6cqmin; text-align: center; color: var(--predictor-light); margin-top: 0.2cqmin; }

    .stack-count {
        position: absolute; top: -0.5cqmin; right: -0.5cqmin;
        background: var(--gold); color: var(--bg-dark); font-size: 1cqmin;
        width: 2cqmin; height: 2cqmin; display: flex; align-items: center; justify-content: center;
        border: 0.1cqmin solid var(--gold-dark); z-index: 5;
    }

    .action-bar {
        height: 8%; width: 100%; flex-shrink: 0;
        display: flex; gap: 1cqmin; padding: 0 2cqmin;
        background: #0d0d22; border-top: 0.1cqmin solid rgba(255,255,255,0.1);
        justify-content: center; align-items: center;
    }
    .action-btn {
        font-family: 'Press Start 2P', monospace; font-size: 1.2cqmin; padding: 1cqmin 2cqmin;
        border: 0.2cqmin solid; background: transparent; cursor: pointer; color: var(--white);
        border-color: var(--gray); transition: all 0.1s;
    }
    .action-btn:hover:not(:disabled) { transform: translateY(-0.2cqmin); background: rgba(255,255,255,0.1);}
    .action-btn:disabled { opacity: 0.3; cursor: not-allowed; }
    .action-btn.summon { border-color: var(--gold); color: var(--gold); }
    .action-btn.attack { border-color: var(--outcome-light); color: var(--outcome-light); }
    .action-btn.meta { border-color: var(--meta); color: var(--meta); }
    .action-btn.end-turn { border-color: var(--predictor-light); color: var(--predictor-light); }
    .action-btn.cancel { border-color: var(--gray); color: var(--gray); display: none; }

    .hand-area {
        height: 22%; width: 100%; flex-shrink: 0;
        background: #0d0d22; border-top: 0.2cqmin solid var(--gray);
        padding: 0.5cqmin 2cqmin; display: flex; flex-direction: column;
    }
    .hand-label { font-size: 1cqmin; color: var(--gray); margin-bottom: 0.5cqmin; display: flex; justify-content: space-between; flex-shrink: 0;}
    .hand-cards { display: flex; gap: 1cqmin; overflow-x: auto; overflow-y: hidden; flex: 1; align-items: center; padding-bottom: 0.5cqmin;}

    .card-slot.highlight { border-color: var(--gold); background: rgba(255,204,0,0.08); animation: slotPulse 0.8s ease-in-out infinite; }
    .card-slot.attack-target { border-color: var(--outcome-light); background: rgba(204,34,68,0.15); cursor: pointer; }
    .card-slot.spell-target { border-color: var(--spell); background: rgba(34,204,136,0.15); animation: slotPulse 0.8s ease-in-out infinite; cursor: pointer; }
    .card-slot.resource-target { border-color: var(--resource); background: rgba(255,152,0,0.15); animation: slotPulse 0.8s ease-in-out infinite; cursor: pointer; }
    .monster-card.can-attack { animation: monsterReady 1s ease-in-out infinite; }
    .monster-card.attacking { box-shadow: 0 0 2cqmin var(--outcome-light); border-color: var(--outcome-light); }

    #flash-overlay { position: absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; z-index: 9; }
    .flash-attack { animation: fAtk 0.2s ease-out; }
    .flash-error { animation: fErr 0.6s ease-out; }
    .flash-heal { animation: fHeal 0.4s ease-out; }
    .flash-meta { animation: fMeta 0.8s ease-out; }

    @keyframes fAtk { 0% { background-color: rgba(255,255,255,0.8); } 100% { background-color: transparent; } }
    @keyframes fErr { 0% { background-color: rgba(255,0,0,0.8); } 100% { background-color: transparent; } }
    @keyframes fHeal { 0% { background-color: rgba(0,255,0,0.6); } 100% { background-color: transparent; } }
    @keyframes fMeta { 0% { background-color: rgba(224,64,251,0.8); } 100% { background-color: transparent; } }
    @keyframes blink { 50% { opacity: 0.4; } }
    @keyframes slotPulse { 0%, 100% { box-shadow: inset 0 0 0.5cqmin rgba(255,204,0,0.1); } 50% { box-shadow: inset 0 0 1.5cqmin rgba(255,204,0,0.3); } }
    @keyframes shake { 0%, 100% { transform: translate(0,0); } 20% { transform: translate(-1cqmin,0.5cqmin); } 40% { transform: translate(1cqmin,-0.5cqmin); } 60% { transform: translate(-1cqmin,-0.5cqmin); } 80% { transform: translate(1cqmin,0.5cqmin); } }
    .shake-anim { animation: shake 0.4s ease-in-out; }

    .game-log {
        position: absolute; bottom: 24%; right: 2%; width: 25%; max-height: 15%;
        overflow-y: auto; background: rgba(10,10,26,0.92); border: 0.2cqmin solid var(--gray); padding: 1cqmin;
        font-size: 0.9cqmin; line-height: 1.4; z-index: 50;
    }
    .log-entry { margin-bottom: 0.5cqmin; padding-bottom: 0.5cqmin; border-bottom: 0.1cqmin solid rgba(255,255,255,0.05); }
    .log-entry.formula-log { color: var(--gold); }
    .log-entry.battle-log { color: var(--outcome-light); }
    .log-entry.info-log { color: var(--predictor-light); }
    .log-entry.spell-log { color: var(--spell); }
    .log-entry.error-log { color: var(--outcome); }
    .log-entry.meta-log { color: var(--meta); font-weight: bold; }

    .damage-number {
        position: fixed; font-family: 'Press Start 2P', monospace; font-size: 3vmin; color: #ff4444;
        text-shadow: 0.3vmin 0.3vmin 0 #000; z-index: 9000; pointer-events: none; animation: floatUp 1.5s ease-out forwards;
    }
    @keyframes floatUp { 0% { opacity: 1; transform: translateY(0) scale(1); } 100% { opacity: 0; transform: translateY(-8vmin) scale(1.5); } }

    .opponent-side { transform: scale(0.85); transform-origin: top center; opacity: 0.9; }
    .field-divider { height: 0.3cqmin; width: 100%; background: linear-gradient(90deg, transparent, var(--gray), transparent); margin: 0.5cqmin 0; flex-shrink: 0;}

    .tooltip {
        display: none; position: fixed; background: #1a1a3a; border: 0.3vmin solid var(--gold); padding: 1.5vmin;
        font-size: 1.2vmin; line-height: 1.8; z-index: 5000; width: auto; max-width: 45vmin; pointer-events: none;
    }
    .tooltip.active { display: block; }
    .card-back { width: 4.5cqmin; height: 6cqmin; background: repeating-linear-gradient(45deg, #1a1a3a, #1a1a3a 0.5cqmin, #222244 0.5cqmin, #222244 1cqmin); border: 0.2cqmin solid var(--gray); flex-shrink: 0; display:flex; align-items:center; justify-content:center;}

    .end-screen {
        position: absolute; inset: 0; background: rgba(0,0,0,0.95);
        display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 3000; text-align: center;
    }
    .end-screen.active { display: flex; }
    .end-screen h1 { font-size: 6cqmin; margin-bottom: 2cqmin; }
    .end-screen p { font-size: 2cqmin; color: var(--gray); margin-bottom: 4cqmin; max-width: 60cqmin; line-height: 1.8; }

    .lp-target { border: 0.3cqmin solid var(--outcome-light) !important; animation: slotPulse 0.6s ease-in-out infinite; cursor: pointer; }

    #dice-modal {
        position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
        background: #111; border: 0.4cqmin solid var(--gold); padding: 3cqmin;
        text-align: center; z-index: 4000; display: none;
        box-shadow: 0 0 5cqmin rgba(0,0,0,0.8);
    }
    #dice-result { font-size: 6cqmin; color: #fff; margin: 2cqmin 0; animation: pulse 0.1s infinite; }
    #dice-text { font-size: 1.5cqmin; color: var(--predictor-light); }
    @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.1); } }

    @keyframes monsterReady { 0%, 100% { box-shadow: 0 0 1cqmin rgba(255,204,0,0.2); } 50% { box-shadow: 0 0 2cqmin rgba(255,204,0,0.5); } }
</style>
</head>
<body>

<div id="game-container">
    <div id="flash-overlay"></div>

    <div id="dice-modal">
        <div style="color:var(--gold); font-size: 2cqmin;">ROLLING D20...</div>
        <div id="dice-result">--</div>
        <div id="dice-text">Target: ‚â§ X to achieve P < .05</div>
    </div>

    <!-- ===== TITLE / LOBBY ===== -->
    <div id="title-screen">
        <h1>VALIDITY WARS</h1>
        <h2>POWER PROTOCOL ‚Äî MODE SELECTOR</h2>

        <div id="main-menu" class="lobby-section">
            <button class="start-btn" onclick="showMenu('online')">ONLINE MULTIPLAYER</button>
            <button class="start-btn" onclick="showMenu('single')">SINGLE PLAYER</button>
            <button class="how-to-btn" onclick="showCardGallery()">CARD GALLERY</button>
            <button class="how-to-btn" onclick="showTutorial()">HOW TO PLAY</button>
        </div>

        <div id="lobby-menu" class="lobby-section" style="display:none;">
            <div class="menu-subtitle">ONLINE MODE SELECTOR</div>
            <button class="start-btn" onclick="createRoom()">CREATE ROOM</button>
            <div class="lobby-or">‚Äî OR ‚Äî</div>
            <div class="lobby-row">
                <input type="text" class="lobby-input" id="join-code-input" maxlength="10" placeholder="ROOM CODE" autocomplete="off">
                <button class="start-btn" style="font-size:1.5cqmin; padding:1.5cqmin 2cqmin;" onclick="joinRoom()">JOIN</button>
            </div>
            <div class="lobby-row" style="margin-top:0.5cqmin;">
                <button class="how-to-btn" onclick="showMenu('main')" style="margin-top:0;">BACK</button>
                <button class="how-to-btn" onclick="showTutorial()" style="margin-top:0;">HOW TO PLAY</button>
            </div>
        </div>

        <div id="single-menu" class="lobby-section" style="display:none;">
            <div class="menu-subtitle">SINGLE PLAYER MODE SELECTOR</div>
            <div class="menu-subtitle" style="color:var(--predictor-light);">CHOOSE AI DIFFICULTY</div>
            <div class="difficulty-grid" id="difficulty-grid">
                <button class="difficulty-btn" data-difficulty="rookie" onclick="selectAIDifficulty('rookie')">ROOKIE</button>
                <button class="difficulty-btn" data-difficulty="balanced" onclick="selectAIDifficulty('balanced')">BALANCED</button>
                <button class="difficulty-btn" data-difficulty="strong" onclick="selectAIDifficulty('strong')">STRONG</button>
                <button class="difficulty-btn" data-difficulty="expert" onclick="selectAIDifficulty('expert')">EXPERT</button>
            </div>
            <div class="lobby-status" id="ai-difficulty-desc"></div>
            <button class="start-btn" style="font-size:1.5cqmin; padding:1.5cqmin 2.5cqmin;" onclick="startSinglePlayer()">START SINGLE PLAYER</button>
            <div class="lobby-row" style="margin-top:0.5cqmin;">
                <button class="how-to-btn" onclick="showMenu('main')" style="margin-top:0;">BACK</button>
                <button class="how-to-btn" onclick="showTutorial()" style="margin-top:0;">HOW TO PLAY</button>
            </div>
        </div>

        <div id="lobby-waiting" class="lobby-section" style="display:none;">
            <div style="font-size:1.5cqmin; color:var(--white); margin-bottom:1cqmin;">ROOM CODE:</div>
            <div class="lobby-code-display" id="room-code-display" onclick="copyRoomCode()"></div>
            <div class="lobby-status" id="lobby-status">Waiting for opponent...</div>
            <button class="how-to-btn" onclick="showTutorial()">HOW TO PLAY</button>
        </div>
    </div>

    <div class="modal-overlay" id="tutorial-modal">
        <div class="modal-box">
            <h2>HOW TO PLAY</h2>

            <h3>1. Objective (What ‚ÄúWinning‚Äù Means)</h3>
            <p>Your goal is to reduce your opponent‚Äôs LP (Life Points) from <strong>8000 to 0</strong>. You do this by summoning monsters from <em>Predictor √ó Outcome</em> construct pairings and attacking.</p>
            <p>Think like a psychometrician: stronger measurement quality (reliability) and larger samples (N) help you estimate effects more accurately and make successful attacks more likely.</p>
            <p><strong>Opening setup:</strong> Each player begins with a <strong>10-card hand</strong> and gets a <strong>one-time mulligan</strong> (choose any opening cards to replace before turn 1).</p>

            <h3>2. Card Types (What Each Color Does)</h3>
            <p>
            <span style="color:var(--predictor-light)">BLUE = Predictor items</span> (e.g., Cognitive Ability)<br>
            <span style="color:var(--outcome-light)">RED = Outcome items</span> (e.g., Job Performance)<br>
            <span style="color:var(--resource)">ORANGE = Resource cards</span> (increase sample size / N)<br>
            <span style="color:var(--spell)">GREEN = Spells</span> (special effects)<br>
            <span style="color:var(--trap)">PURPLE = Traps / debuffs</span> (weaken enemies)
            </p>
            <p>Hover cards and monsters to inspect details such as average inter-item correlation (rÃÑ), reliability (Œ±), observed validity, true validity (œÅ), sample size, and power.</p>

            <h3>3. Construct Phase (Placing & Stacking Items)</h3>
            <p>Click a card in your hand, then click a construct slot to place it.</p>
            <p><strong>Stacking rule:</strong> you may stack up to <strong>3 identical construct items</strong> in the same slot (same construct only). Example: stack multiple Cognitive Ability items together.</p>
            <p>Stacking increases construct reliability (Œ±) via the Spearman-Brown principle. In plain language: <strong>more good items = more reliable measurement</strong>.</p>
            <p>Higher reliability improves the monster you summon from that construct later (better observed validity and more effective attacks).</p>

            <h3>4. Summoning Phase (Making a Monster)</h3>
            <p>To summon, you must control at least one <span style="color:var(--predictor-light)">Predictor</span> construct and one <span style="color:var(--outcome-light)">Outcome</span> construct.</p>
            <p>Press <strong>SUMMON</strong>, then select:</p>
            <p>
            ‚Ä¢ one Predictor construct slot<br>
            ‚Ä¢ one Outcome construct slot
            </p>
            <p>The game combines them into a monster. The monster‚Äôs combat stats reflect the quality of your measurement model:</p>
            <p>
            ‚Ä¢ <strong>True validity (œÅ)</strong> = underlying relationship between predictor and outcome<br>
            ‚Ä¢ <strong>Observed validity</strong> is attenuated by measurement error (reliability matters)<br>
            ‚Ä¢ <strong>ATK</strong> is derived from the resulting effect strength
            </p>
            <p><strong>Important:</strong> you can normally summon only <strong>once per turn</strong>.</p>

            <h3>5. Battle Phase (Power, D20, and Significance)</h3>
            <p>Press <strong>BATTLE</strong>, select one of your monsters, then choose a target (enemy monster, or direct LP attack if no enemy monsters are on the field).</p>
            <p>Each attack requires a <strong>D20 significance roll</strong>. Your monster must achieve <strong>P &lt; .05</strong> to land the attack.</p>
            <p>Your success chance is your <strong>statistical power (1 ‚àí Œ≤)</strong>. The higher the power, the easier the D20 threshold.</p>
            <p>Example: if Power = 80%, you must roll <strong>16 or lower</strong> on a D20. If you roll above the threshold, the attack fails (a <span style="color:var(--outcome)">Type II Error</span>).</p>
            <p><strong>Fairness gate:</strong> monsters with 3 stars or fewer cannot attack unless <span style="color:var(--spell)">Job Relevance</span> is equipped to them.</p>

            <h3>6. Sample Size (N) and Why Your Attack ‚ÄúUses Data‚Äù</h3>
            <p>Monsters start with a small pilot sample (low N), which usually means low power.</p>
            <p>Use <span style="color:var(--resource)">Sample Size</span> cards on your monster to increase N and improve power before attacking.</p>
            <p><strong>Critical rule:</strong> an attack consumes the sample. After attacking, N usually resets to baseline (your data were ‚Äúspent‚Äù), whether the attack hit or missed.</p>
            <p>This creates a real tradeoff: invest in power before high-value attacks, rather than attacking immediately with weak evidence.</p>

            <h3>7. Spells, Traps, and Timing Tips</h3>
            <p>
            ‚Ä¢ <span style="color:var(--trap)">Missing Data</span>: destroy any card on the field (monster or construct). Great for disrupting stacked constructs or removing a dangerous monster.<br>
            ‚Ä¢ <span style="color:var(--spell)">P-hacking</span>: equip to your monster. Its next attack cannot miss, but the equipped monster is destroyed after that attack.<br>
            ‚Ä¢ <span style="color:var(--spell)">Job Relevance</span>: equip to your monster. Monsters with 3 stars or fewer need it to attack.<br>
            ‚Ä¢ <span style="color:var(--trap)">Range Restriction</span>: target enemy monster; halves its ATK (attenuation in action).<br>
            ‚Ä¢ <span style="color:var(--gold)">Correction for Attenuation</span>: target your monster; sets ATK to r_true √ó 10,000 for one turn.
            </p>

            <h3>8. META Phase (Meta-Analysis Ultimate Summon)</h3>
            <p>If you control <strong>3 monsters</strong> and they share the <strong>exact same Predictor</strong> <em>or</em> the <strong>exact same Outcome</strong>, press <strong>META</strong>.</p>
            <p>The 3 monsters are sacrificed to summon a <strong>Meta-Analytic Titan</strong> with very high power and strong stats. This is your big ‚Äúevidence aggregation‚Äù play.</p>

            <h3>9. Turn Flow (Beginner-Friendly Checklist)</h3>
            <p>
            1) Place/stack construct items to increase reliability<br>
            2) Summon a monster (Predictor + Outcome)<br>
            3) Use Sample Size / Spells / Traps to prepare the board<br>
            4) Enter Battle and attack with sufficient power<br>
            5) End turn
            </p>
            <p><strong>Beginner tip:</strong> Don‚Äôt rush attacks. A more reliable construct stack + larger N usually produces better outcomes than a fast low-power attack.</p>
            <button class="how-to-btn" style="display:block; margin: 2cqmin auto 0;" onclick="closeTutorial()">I UNDERSTAND</button>
        </div>
    </div>

    <div class="modal-overlay" id="card-gallery-modal">
        <div class="modal-box">
            <div class="gallery-header">
                <h2>CARD GALLERY</h2>
                <div class="gallery-subtitle">Retro binder mode ‚Äî scroll each row like classic handheld duels.</div>
            </div>
            <div class="gallery-scroll" id="card-gallery-content"></div>
            <button class="how-to-btn" style="display:block; margin: 2cqmin auto 0;" onclick="closeCardGallery()">BACK TO MENU</button>
        </div>
        <div id="gallery-zoom-overlay" class="gallery-zoom-overlay" onclick="onGalleryZoomOverlayClick(event)">
            <button class="gallery-zoom-close" type="button" onclick="closeGalleryZoom(event)">CLOSE</button>
            <article class="gallery-zoom-card" role="dialog" aria-label="Enlarged card view"></article>
        </div>
    </div>

    <div class="modal-overlay" id="mulligan-modal">
        <div class="modal-box">
            <h2>OPENING MULLIGAN</h2>
            <p>Select any number of cards to replace, then confirm. Replaced cards are shuffled into your deck and redrawn (Hearthstone-style).</p>
            <p class="mulligan-subtext" id="mulligan-status">Select cards to replace.</p>

            <div class="mulligan-grid" id="mulligan-hand"></div>

            <div style="display:flex; gap:1cqmin; justify-content:center; margin-top: 2.5cqmin; flex-wrap:wrap;">
                <button class="how-to-btn" style="margin-top:0;" onclick="keepOpeningHand()">KEEP ALL</button>
                <button class="start-btn" style="font-size:1.2cqmin; padding:1.4cqmin 2cqmin;" onclick="confirmMulligan()">
                    CONFIRM MULLIGAN (<span id="mulligan-count">0</span>)
                </button>
                <button class="how-to-btn" style="margin-top:0;" onclick="showTutorial()">HOW TO PLAY</button>
            </div>
        </div>
    </div>

    <!-- ===== GAME SCREEN ===== -->
    <div id="game-screen">
        <div class="top-bar">
            <div class="lp-display">
                <span class="lp-label">OPP LP</span>
                <div class="lp-bar"><div class="lp-fill" id="opp-lp-bar" style="width:100%"></div></div>
                <span class="lp-value" id="opp-lp">8000</span>
            </div>
            <div class="turn-indicator" id="turn-indicator">WAITING</div>
            <div class="lp-display">
                <span class="lp-value" id="player-lp">8000</span>
                <div class="lp-bar"><div class="lp-fill" id="player-lp-bar" style="width:100%"></div></div>
                <span class="lp-label">YOUR LP</span>
            </div>
        </div>

        <button class="persistent-help-link" onclick="showTutorial()">HOW TO PLAY</button>

        <div class="game-board">
            <div class="opponent-side">
                <div class="field-row" id="opp-hand-row" style="justify-content:center; gap: 0.5cqmin; margin-bottom: 0.5cqmin; height: 6cqmin;"></div>
                <div class="field-row">
                    <span class="field-label" style="color:var(--outcome-light)">MONSTERS</span>
                    <div class="card-slot" id="opp-monster-0"></div>
                    <div class="card-slot" id="opp-monster-1"></div>
                    <div class="card-slot" id="opp-monster-2"></div>
                </div>
                <div class="field-row">
                    <span class="field-label">CONSTRUCTS</span>
                    <div class="card-slot" id="opp-construct-0"></div>
                    <div class="card-slot" id="opp-construct-1"></div>
                    <div class="card-slot" id="opp-construct-2"></div>
                </div>
            </div>
            <div class="field-divider"></div>
            <div>
                <div class="field-row">
                    <span class="field-label">CONSTRUCTS</span>
                    <div class="card-slot" id="player-construct-0" onclick="onConstructSlotClick(0)"></div>
                    <div class="card-slot" id="player-construct-1" onclick="onConstructSlotClick(1)"></div>
                    <div class="card-slot" id="player-construct-2" onclick="onConstructSlotClick(2)"></div>
                </div>
                <div class="field-row">
                    <span class="field-label" style="color:var(--gold)">MONSTERS</span>
                    <div class="card-slot" id="player-monster-0" onclick="onMonsterSlotClick(0)"></div>
                    <div class="card-slot" id="player-monster-1" onclick="onMonsterSlotClick(1)"></div>
                    <div class="card-slot" id="player-monster-2" onclick="onMonsterSlotClick(2)"></div>
                </div>
            </div>
        </div>

        <div class="action-bar" id="action-bar">
            <button class="action-btn summon" id="btn-summon" onclick="startSummon()" disabled>SUMMON</button>
            <button class="action-btn meta" id="btn-meta" onclick="doMeta()" disabled>META</button>
            <button class="action-btn attack" id="btn-attack" onclick="startAttack()" disabled>BATTLE</button>
            <button class="action-btn cancel" id="btn-cancel" onclick="cancelAction()">CANCEL</button>
            <button class="action-btn end-turn" id="btn-end" onclick="doEndTurn()" disabled>END TURN</button>
        </div>

        <div class="hand-area">
            <div class="hand-label">
                <span>YOUR HAND</span>
                <span id="deck-count" style="color:var(--gray)">DECK: 0</span>
            </div>
            <div class="hand-cards" id="player-hand"></div>
        </div>
    </div>

    <div class="end-screen" id="end-screen">
        <h1 id="end-title"></h1>
        <p id="end-message"></p>
        <button class="start-btn" onclick="location.reload()">PLAY AGAIN</button>
    </div>

    <div class="game-log" id="game-log"></div>
</div>

<div class="tooltip" id="tooltip"></div>

<script src="ai/singlePlayerMcts.js"></script>
<script>
// ==================== CONFIG ====================
const API_URL = 'api.php'; // Change to your API endpoint
const MAX_HAND_SIZE = 10;
const STARTING_HAND_SIZE = 10;

// ==================== PSYCHOMETRICS DATA (for tooltips) ====================
const CONSTRUCTS = {
    cog_ability: { name: "Cognitive Ability", type: "predictor", short: "COG", avgR: 0.65, sprite: "üß†", indicators: [{ name: "GMA Test", r: 0.67 }, { name: "Wonderlic", r: 0.63 }, { name: "Raven's", r: 0.64 }] },
    conscient: { name: "Conscientiousness", type: "predictor", short: "CON", avgR: 0.45, sprite: "üìã", indicators: [{ name: "NEO-PI-R C", r: 0.47 }, { name: "BFI Consc.", r: 0.43 }, { name: "HEXACO C", r: 0.45 }] },
    struct_int: { name: "Struct. Interview", type: "predictor", short: "INT", avgR: 0.55, sprite: "üé§", indicators: [{ name: "Behavioral", r: 0.56 }, { name: "Situational", r: 0.53 }, { name: "Panel Rtg", r: 0.55 }] },
    work_sample: { name: "Work Sample", type: "predictor", short: "WST", avgR: 0.50, sprite: "üîß", indicators: [{ name: "In-Basket", r: 0.48 }, { name: "Role Play", r: 0.52 }, { name: "Present.", r: 0.50 }] },

    job_perf: { name: "Job Performance", type: "outcome", short: "PERF", avgR: 0.52, sprite: "‚≠ê", indicators: [{ name: "Super. Rtg", r: 0.54 }, { name: "Obj. Output", r: 0.50 }, { name: "Peer Rtg", r: 0.52 }] },
    turnover: { name: "Turnover", type: "outcome", short: "TURN", avgR: 0.40, sprite: "üö™", indicators: [{ name: "Intent Quit", r: 0.42 }, { name: "Actual Quit", r: 0.38 }, { name: "Absent", r: 0.40 }] },
    job_sat: { name: "Job Satisfaction", type: "outcome", short: "SAT", avgR: 0.48, sprite: "üòä", indicators: [{ name: "JDI Scale", r: 0.50 }, { name: "MSQ Score", r: 0.47 }, { name: "Faces Scale", r: 0.47 }] },
    ocb: { name: "OCB", type: "outcome", short: "OCB", avgR: 0.44, sprite: "ü§ù", indicators: [{ name: "OCBI Items", r: 0.46 }, { name: "OCBO Items", r: 0.42 }, { name: "Altruism", r: 0.44 }] }
};

const TRUE_VALIDITY = {
    cog_ability: { job_perf: 0.51, turnover: 0.20, job_sat: 0.15, ocb: 0.12 },
    conscient:   { job_perf: 0.31, turnover: 0.26, job_sat: 0.25, ocb: 0.30 },
    struct_int:  { job_perf: 0.51, turnover: 0.22, job_sat: 0.18, ocb: 0.15 },
    work_sample: { job_perf: 0.54, turnover: 0.15, job_sat: 0.12, ocb: 0.10 }
};

// Black-White standardized differences (Cohen's d) where available from the provided table.
// Other outcome pairings are best-practice approximations to keep tradeoffs visible in gameplay.
const ADVERSE_IMPACT_BWD = {
    cog_ability: { job_perf: 0.79, turnover: 0.73, job_sat: 0.70, ocb: 0.68 },
    conscient:   { job_perf: -0.07, turnover: -0.03, job_sat: 0.00, ocb: 0.02 },
    struct_int:  { job_perf: 0.23, turnover: 0.27, job_sat: 0.24, ocb: 0.25 },
    work_sample: { job_perf: 0.67, turnover: 0.62, job_sat: 0.60, ocb: 0.58 }
};

function adverseImpactStarsFromBwd(rawBwd) {
    const d = Math.abs(rawBwd ?? 0);
    if (d <= 0.10) return 5;
    if (d <= 0.25) return 4;
    if (d <= 0.45) return 3;
    if (d <= 0.65) return 2;
    return 1;
}

function requiresJobRelevanceFromStars(stars) {
    return stars <= 3;
}

function getPairAdverseImpact(predId, outId) {
    const bwd = (ADVERSE_IMPACT_BWD[predId] || {})[outId] ?? 0.3;
    const stars = adverseImpactStarsFromBwd(bwd);
    return {
        bwd,
        stars,
        requiresJobRelevance: requiresJobRelevanceFromStars(stars),
        starsText: '‚òÖ'.repeat(stars) + '‚òÜ'.repeat(5 - stars)
    };
}

const MONSTER_NAMES = {
    cog_ability: {
        job_perf: "Sapient Performer",
        turnover: "Logic Guardian",
        job_sat: "Mind's Content",
        ocb: "Brilliant Helper"
    },
    conscient: {
        job_perf: "Diligent Titan",
        turnover: "Steadfast Anchor",
        job_sat: "Dutiful Spirit",
        ocb: "Noble Worker"
    },
    struct_int: {
        job_perf: "Interview Sage",
        turnover: "Vetting Sentinel",
        job_sat: "Rapport Weaver",
        ocb: "Dialogue Knight"
    },
    work_sample: {
        job_perf: "Craft Master",
        turnover: "Task Binder",
        job_sat: "Skilled Spirit",
        ocb: "Practice Hero"
    }
};

const MONSTER_SPRITES = ['‚öîÔ∏è','üêâ','ü¶Å','üî•','üíé','üåü','üó°Ô∏è','üõ°Ô∏è','üëÅÔ∏è','üåÄ'];

function spearmanBrown(k, avgR) { return (k * avgR) / (1 + (k - 1) * avgR); }

// ==================== LOCAL SINGLE-PLAYER ENGINE ====================
const AI_DIFFICULTY_PROFILES = window.PsychometricDuelMctsAI?.PROFILES || {
    rookie: { label: 'Rookie', description: 'Forgiving AI', thinkMs: 220 },
    balanced: { label: 'Balanced', description: 'Solid AI', thinkMs: 700 },
    strong: { label: 'Strong', description: 'Optimized AI', thinkMs: 1800 },
    expert: { label: 'Expert', description: 'Very strong AI', thinkMs: 3600 }
};
function getAIProfile() {
    const key = session?.aiDifficulty || 'strong';
    return AI_DIFFICULTY_PROFILES[key] || AI_DIFFICULTY_PROFILES.strong;
}
function showMenu(view) {
    const main = document.getElementById('main-menu');
    const online = document.getElementById('lobby-menu');
    const single = document.getElementById('single-menu');
    const waiting = document.getElementById('lobby-waiting');
    if (waiting && waiting.style.display !== 'none') return;
    if (main) main.style.display = (view === 'main') ? 'flex' : 'none';
    if (online) online.style.display = (view === 'online') ? 'flex' : 'none';
    if (single) single.style.display = (view === 'single') ? 'flex' : 'none';
    if (view === 'single') updateAIDifficultyUI();
}
function updateAIDifficultyUI() {
    const key = session?.aiDifficulty || 'strong';
    document.querySelectorAll('#difficulty-grid .difficulty-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.difficulty === key);
    });
    const desc = document.getElementById('ai-difficulty-desc');
    if (desc) {
        const p = AI_DIFFICULTY_PROFILES[key] || AI_DIFFICULTY_PROFILES.strong;
        desc.innerHTML = `<span style=\"color:var(--gold)\">${p.label}</span> ‚Äî ${p.description}`;
    }
}
function selectAIDifficulty(key) {
    if (!AI_DIFFICULTY_PROFILES[key]) return;
    session.aiDifficulty = key;
    updateAIDifficultyUI();
}

function showCardGallery() {
    renderCardGallery();
    document.getElementById('card-gallery-modal').classList.add('active');
}

function closeCardGallery() {
    closeGalleryZoom();
    document.getElementById('card-gallery-modal').classList.remove('active');
}

function escapeHtml(text) {
    return String(text ?? '')
        .replaceAll('&', '&amp;')
        .replaceAll('<', '&lt;')
        .replaceAll('>', '&gt;')
        .replaceAll('"', '&quot;')
        .replaceAll("'", '&#039;');
}

function renderGalleryDetails(card, isZoom = false) {
    if (card.detailType !== 'pairings') {
        return `<div class="${isZoom ? 'gallery-zoom-copy' : 'gallery-copy'}">${escapeHtml(card.copy)}</div>`;
    }

    const rows = (card.pairings || [])
        .map(pair => `<tr><td>${escapeHtml(pair.pair)}</td><td>œÅ ${Number(pair.validity).toFixed(2)}</td><td>${escapeHtml(pair.fairnessStars)}</td></tr>`)
        .join('');

    return `
        <div class="${isZoom ? 'gallery-zoom-reliability' : 'gallery-reliability'}">Reliability ${escapeHtml(card.reliabilityLabel || 'r')} = ${Number(card.reliability || 0).toFixed(2)}</div>
        <table class="gallery-pair-table${isZoom ? ' zoom' : ''}">
            <thead><tr><th>Pair</th><th>Validity</th><th>Fairness</th></tr></thead>
            <tbody>${rows}</tbody>
        </table>
    `;
}

function openGalleryZoom(card) {
    const overlay = document.getElementById('gallery-zoom-overlay');
    if (!overlay || !card) return;
    const zoomCard = overlay.querySelector('.gallery-zoom-card');
    if (!zoomCard) return;
    overlay.className = `gallery-zoom-overlay active ${card.cssClass}`;
    zoomCard.innerHTML = `
        <div class="gallery-badge">${escapeHtml(card.badge)}</div>
        <h3 class="gallery-zoom-title">${escapeHtml(card.name)}</h3>
        ${card.detailType === 'pairings' ? '' : `<div class="gallery-zoom-icon">${escapeHtml(card.icon)}</div>`}
        ${renderGalleryDetails(card, true)}
    `;
}

function closeGalleryZoom(event = null) {
    if (event) event.stopPropagation();
    const overlay = document.getElementById('gallery-zoom-overlay');
    if (!overlay) return;
    overlay.className = 'gallery-zoom-overlay';
}

function onGalleryZoomOverlayClick(event) {
    if (event.target.id === 'gallery-zoom-overlay') closeGalleryZoom();
}

document.addEventListener('keydown', event => {
    if (event.key === 'Escape') closeGalleryZoom();
});

let galleryCardLookup = [];

function renderGalleryCard(card) {
    const galleryIdx = galleryCardLookup.push(card) - 1;
    return `
        <article class="gallery-card ${card.cssClass}" tabindex="0" data-gallery-idx="${galleryIdx}" onclick="onGalleryCardSelected(event)" onkeydown="onGalleryCardKeydown(event)">
            <div class="gallery-badge">${escapeHtml(card.badge)}</div>
            <div class="gallery-name">${escapeHtml(card.name)}</div>
            ${card.detailType === 'pairings' ? '' : `<div class="gallery-icon">${escapeHtml(card.icon)}</div>`}
            ${renderGalleryDetails(card)}
        </article>
    `;
}

function onGalleryCardSelected(event) {
    const el = event.currentTarget;
    if (!el?.dataset) return;
    const card = galleryCardLookup[Number(el.dataset.galleryIdx)];
    if (!card) return;
    openGalleryZoom(card);
}

function onGalleryCardKeydown(event) {
    if (event.key !== 'Enter' && event.key !== ' ') return;
    event.preventDefault();
    onGalleryCardSelected(event);
}

function renderGallerySection(title, cards) {
    return `
        <section class="gallery-section">
            <div class="gallery-section-title">${title}</div>
            <div class="gallery-cards-row">${cards.map(renderGalleryCard).join('')}</div>
        </section>
    `;
}

function renderCardGallery() {
    const container = document.getElementById('card-gallery-content');
    if (!container) return;
    galleryCardLookup = [];

    const formatPairingLine = (pairLabel, validity, starsText) => `${pairLabel}: œÅ=${validity.toFixed(2)} ¬∑ Fairness ${starsText}`;

    const predictorCards = Object.entries(CONSTRUCTS)
        .filter(([, c]) => c.type === 'predictor')
        .flatMap(([id, c]) => (c.indicators || []).map(ind => ({
            cssClass: 'predictor',
            badge: 'PREDICTOR SCALE',
            name: `${c.short} ‚Äî ${ind.name}`,
            icon: c.sprite || LOCAL_SPRITES[id] || 'üß†',
            detailType: 'pairings',
            reliabilityLabel: 'r',
            reliability: ind.r,
            pairings: Object.entries(TRUE_VALIDITY[id] || []).map(([outId, validity]) => {
                const fairness = getPairAdverseImpact(id, outId);
                return { pair: CONSTRUCTS[outId].short, validity, fairnessStars: fairness.starsText };
            })
        })));

    const outcomeCards = Object.entries(CONSTRUCTS)
        .filter(([, c]) => c.type === 'outcome')
        .flatMap(([id, c]) => (c.indicators || []).map(ind => ({
            cssClass: 'outcome',
            badge: 'OUTCOME SCALE',
            name: `${c.short} ‚Äî ${ind.name}`,
            icon: c.sprite || LOCAL_SPRITES[id] || 'üéØ',
            detailType: 'pairings',
            reliabilityLabel: 'r',
            reliability: ind.r,
            pairings: Object.keys(TRUE_VALIDITY)
                .filter(predId => TRUE_VALIDITY[predId]?.[id] !== undefined)
                .map(predId => {
                    const validity = TRUE_VALIDITY[predId][id];
                    const fairness = getPairAdverseImpact(predId, id);
                    return { pair: CONSTRUCTS[predId].short, validity, fairnessStars: fairness.starsText };
                })
        })));

    const monsters = [];
    const predictors = Object.keys(TRUE_VALIDITY);
    predictors.forEach(predId => {
        Object.entries(TRUE_VALIDITY[predId]).forEach(([outId, validity]) => {
            const ai = getPairAdverseImpact(predId, outId);
            monsters.push({
                cssClass: 'monster',
                badge: 'MONSTER',
                name: getFunMonsterName(predId, outId),
                icon: getMonsterSpriteForPair(predId, outId),
                copy: `${CONSTRUCTS[predId].short} √ó ${CONSTRUCTS[outId].short} ¬∑ œÅ=${validity.toFixed(2)} | Fairness ${ai.starsText}`
            });
        });
    });

    const spells = Object.values(LOCAL_SPELL_CARDS)
        .filter(c => c.type === 'spell' || c.type === 'resource')
        .map(c => ({
            cssClass: 'spell',
            badge: c.type === 'resource' ? 'SPELL / RESOURCE' : 'SPELL',
            name: c.name,
            icon: c.icon,
            copy: c.desc
        }));

    const traps = Object.values(LOCAL_SPELL_CARDS)
        .filter(c => c.type === 'trap')
        .map(c => ({
            cssClass: 'trap',
            badge: 'TRAP',
            name: c.name,
            icon: c.icon,
            copy: c.desc
        }));

    const meta = [{
        cssClass: 'meta',
        badge: 'META',
        name: 'Meta-Analytic Titan',
        icon: '‚àû',
        copy: 'Fuse 3 monsters. Keeps strongest effect estimate and powers late-game swings.'
    }];

    container.innerHTML = [
        renderGallerySection('Predictors', predictorCards),
        renderGallerySection('Outcome', outcomeCards),
        renderGallerySection('Monsters', monsters),
        renderGallerySection('Spells', spells),
        renderGallerySection('Traps', traps),
        renderGallerySection('Meta', meta)
    ].join('');
}

let localGame = null;

const LOCAL_SPRITES = {
    cog_ability: 'üß†', conscient: '‚úÖ', struct_int: 'üó£Ô∏è', work_sample: 'üß™',
    job_perf: 'üèÜ', turnover: 'üö™', job_sat: 'üòä', ocb: 'ü§ù'
};

const LOCAL_SPELL_CARDS = {
    sample_size: { id: 'sample_size', type: 'resource', icon: 'N+100', name: 'Sample Size', desc: 'Increase target friendly monster sample size (N), boosting power.' },
    job_relevance: { id: 'job_relevance', type: 'spell', icon: 'üìå', name: 'Job Relevance', desc: 'Equip to your monster. Monsters with ‚òÖ‚òÖ‚òÖ‚òÜ‚òÜ or less need this to attack.' },
    imputation: { id: 'imputation', type: 'spell', icon: 'ü©π', name: 'Imputation', desc: 'Equip to your monster. If Missing Data targets it, Imputation is destroyed instead.' },
    missing_data: { id: 'missing_data', type: 'trap', icon: '‚àÖ', name: 'Missing Data', desc: 'Destroy any card on the field.' },
    range_restrict: { id: 'range_restrict', type: 'trap', icon: '‚Üî', name: 'Range Restriction', desc: 'Target enemy monster. Halve ATK.' },
    correction: { id: 'correction', type: 'resource', icon: '‚Ü∫', name: 'Correction for Attenuation', desc: 'Target your monster. Set ATK to r_true √ó 10,000 for this turn.' },

    // New psychometrically relevant support / disruption cards
    bootstrapping: { id: 'bootstrapping', type: 'spell', icon: 'üßÆ', name: 'Bootstrapping', desc: 'Target your monster. Permanently increase its base N by 30.' },
    item_analysis: { id: 'item_analysis', type: 'spell', icon: 'üß©', name: 'Automated Item Generation', desc: 'Target your construct stack. Add one matching item (max 3) to improve reliability.' },

    construct_drift: { id: 'construct_drift', type: 'trap', icon: '‚Üò', name: 'Construct Drift', desc: 'Target enemy construct. Remove one stacked item (or destroy stack if only one).' },
    criterion_contam: { id: 'criterion_contam', type: 'trap', icon: '‚ö†', name: 'Attrition', desc: 'Target enemy monster. Permanently halve N.' },
    p_hacking: { id: 'p_hacking', type: 'spell', icon: 'üéØ', name: 'P-hacking', desc: 'Equip to your monster. Its next attack cannot miss, then it is destroyed at the end of that attack.' },
    practice_effect: { id: 'practice_effect', type: 'trap', icon: 'üåÄ', name: 'Practice Effect', desc: 'Equip to a monster. After it attacks, halve its current validity coefficient.' }
};

function deepClone(obj) { return JSON.parse(JSON.stringify(obj)); }
function randInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
function shuffle(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
}
function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }
function alphaFromStack(stack) {
    if (!stack || !stack.cards?.length) return 0;
    return spearmanBrown(stack.cards.length, stack.cards[0].avgR);
}

function hashString(str) {
    let h = 0;
    for (let i = 0; i < str.length; i++) {
        h = ((h << 5) - h + str.charCodeAt(i)) | 0;
    }
    return Math.abs(h);
}

function getFunMonsterName(predId, outId) {
    return MONSTER_NAMES?.[predId]?.[outId]
        || `${CONSTRUCTS[predId]?.short || predId} √ó ${CONSTRUCTS[outId]?.short || outId}`;
}

function getMonsterSpriteForPair(predId, outId) {
    const key = `${predId}|${outId}`;
    const idx = hashString(key) % MONSTER_SPRITES.length;
    return MONSTER_SPRITES[idx];
}

function getMetaTitanName(monsters) {
    if (!monsters || monsters.length < 3) return 'Meta-Analytic Titan';

    const samePred = monsters.every(m => m && m.predId === monsters[0].predId && m.predId !== 'META');
    const sameOut  = monsters.every(m => m && m.outId === monsters[0].outId && m.outId !== 'META');

    if (samePred && CONSTRUCTS[monsters[0].predId]) {
        return `Meta-${CONSTRUCTS[monsters[0].predId].short} Titan`;
    }
    if (sameOut && CONSTRUCTS[monsters[0].outId]) {
        return `Meta-${CONSTRUCTS[monsters[0].outId].short} Titan`;
    }
    return 'Meta-Analytic Titan';
}

/**
 * Optional display fallback for online mode if server returns plain monsters
 * without fun name/sprite.
 */
function ensureMonsterFlavor(m) {
    if (!m) return m;
    if (m.isMeta) {
        if (!m.name) m.name = 'Meta-Analytic Titan';
        if (!m.sprite) m.sprite = 'üåå';
        return m;
    }
    if ((!m.name || m.name.includes('√ó')) && m.predId && m.outId) {
        m.name = getFunMonsterName(m.predId, m.outId);
    }
    if (!m.sprite) {
        m.sprite = getMonsterSpriteForPair(m.predId, m.outId);
    }
    return m;
}

function calcObservedValidity(predStack, outStack) {
    if (!predStack || !outStack) return 0;
    const rho = (TRUE_VALIDITY[predStack.constructId] || {})[outStack.constructId] ?? 0.1;
    const aP = alphaFromStack(predStack);
    const aO = alphaFromStack(outStack);
    return rho * Math.sqrt(Math.max(0.05, aP) * Math.max(0.05, aO));
}
function approxPowerFromROBSandN(rObs, n) {
    const effect = Math.abs(rObs) * Math.sqrt(Math.max(5, n));
    const z = (effect - 1.35) * 1.15;
    return clamp(1 / (1 + Math.exp(-z)), 0.05, 0.99);
}
function getPowerValidityCoefficient(m) {
    if (!m) return 0;
    const validityMultiplier = Math.max(0, m.validityMultiplier ?? 1);
    const coeff = m.correctionApplied ? Math.abs(m.rTrue ?? 0) : Math.abs(m.rObs ?? 0);
    return coeff * validityMultiplier;
}
function refreshMonsterStats(m) {
    if (!m) return;
    if (m.isMeta) {
        m.power = clamp(m.power ?? 0.95, 0.7, 0.99);
        return;
    }
    const validityMultiplier = Math.max(0, m.validityMultiplier ?? 1);
    m.rObs = (m.rTrue * Math.sqrt(Math.max(0.05, m.predAlpha) * Math.max(0.05, m.outAlpha))) * validityMultiplier;
    m.baseAtk = Math.round(Math.abs(m.rObs) * 10000);
    const rangeStacks = Math.max(0, m.rangeRestrictionStacks ?? 0);
    if (rangeStacks > 0) m.atk = Math.max(100, Math.floor(m.baseAtk / (2 ** rangeStacks)));
    else m.atk = m.baseAtk;
    m.power = approxPowerFromROBSandN(getPowerValidityCoefficient(m), m.n);
}

function makeItemCard(constructId, indicatorIndex = null) {
    const c = CONSTRUCTS[constructId];
    const indicators = c.indicators?.length ? c.indicators : [{ name: c.type === 'predictor' ? 'Item indicator' : 'Criterion indicator', r: c.avgR }];
    const picked = indicatorIndex === null
        ? indicators[randInt(0, indicators.length - 1)]
        : indicators[indicatorIndex % indicators.length];
    return {
        isItem: true,
        type: c.type,
        constructId,
        construct: c.name,
        short: c.short,
        avgR: picked.r,
        sprite: c.sprite || LOCAL_SPRITES[constructId] || '‚óè',
        indicator: picked.name
    };
}
function makeSpellCard(id) {
    return deepClone(LOCAL_SPELL_CARDS[id]);
}
function buildStartingDeck() {
    const deck = [];
    const counts = {
        cog_ability: 4, conscient: 4, struct_int: 4, work_sample: 4,
        job_perf: 4, turnover: 4, job_sat: 4, ocb: 4,

        sample_size: 5, job_relevance: 4, imputation: 3, missing_data: 3, range_restrict: 4, correction: 3, p_hacking: 3, practice_effect: 3,

        // New additions
        bootstrapping: 4, item_analysis: 3,
        construct_drift: 3, criterion_contam: 3
    };
    Object.entries(counts).forEach(([id, n]) => {
        for (let i = 0; i < n; i++) {
            if (CONSTRUCTS[id]) {
                const indicators = CONSTRUCTS[id].indicators || [];
                deck.push(makeItemCard(id, indicators.length ? i : null));
            } else deck.push(makeSpellCard(id));
        }
    });
    return shuffle(deck);
}
function drawCards(player, n) {
    for (let i = 0; i < n; i++) {
        if (player.hand.length >= MAX_HAND_SIZE) break;
        if (player.deck.length > 0) player.hand.push(player.deck.pop());
    }
}
function firstEmptySlot(arr) { return arr.findIndex(x => x === null); }
function makeConstructStackFromCard(card) {
    return { type: card.type, constructId: card.constructId, cards: [deepClone(card)] };
}
function findBestSummonPair(player) {
    let best = null;
    for (let i = 0; i < 3; i++) {
        const p = player.constructs[i];
        if (!p || p.type !== 'predictor') continue;
        for (let j = 0; j < 3; j++) {
            const o = player.constructs[j];
            if (!o || o.type !== 'outcome') continue;
            const rObs = calcObservedValidity(p, o);
            const score = rObs + 0.03 * (p.cards.length + o.cards.length);
            if (!best || score > best.score) best = { pred_slot: i, out_slot: j, score };
        }
    }
    return best;
}
function buildMonster(predStack, outStack) {
    const rho = (TRUE_VALIDITY[predStack.constructId] || {})[outStack.constructId] ?? 0.1;
    const ai = getPairAdverseImpact(predStack.constructId, outStack.constructId);
    const predAlpha = alphaFromStack(predStack);
    const outAlpha = alphaFromStack(outStack);

    const m = {
        name: getFunMonsterName(predStack.constructId, outStack.constructId),
        sprite: getMonsterSpriteForPair(predStack.constructId, outStack.constructId),
        predId: predStack.constructId,
        outId: outStack.constructId,
        predAlpha, outAlpha,
        rTrue: rho,
        adverseImpact: ai.bwd,
        adverseStars: ai.stars,
        adverseStarsText: ai.starsText,
        requiresJobRelevance: ai.requiresJobRelevance,
        rObs: 0,
        baseAtk: 0,
        atk: 0,
        baseN: 20,
        n: 20,
        power: 0.1,
        attacksMade: 0,
        maxAttacks: 1,
        summoningSick: true,
        hasJobRelevance: false,
        hasImputation: false,
        hasPHacking: false,
        hasPracticeEffect: false,
        correctionApplied: false,
        rangeRestrictionStacks: 0,
        validityMultiplier: 1,
        isMeta: false
    };

    refreshMonsterStats(m);
    return m;
}
function buildMetaMonster(monsters) {
    const meanR = monsters.reduce((s, m) => s + Math.abs(m.rObs || 0), 0) / monsters.length;
    const meanAtk = monsters.reduce((s, m) => s + (m.atk || 0), 0) / monsters.length;

    return {
        name: getMetaTitanName(monsters),
        sprite: 'üåå',
        predId: 'META',
        outId: 'META',
        predAlpha: 0.99,
        outAlpha: 0.99,
        rTrue: clamp(meanR * 1.35, 0.35, 0.95),
        adverseImpact: 0,
        adverseStars: 5,
        adverseStarsText: '‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ',
        requiresJobRelevance: false,
        rObs: clamp(meanR * 1.25, 0.35, 0.9),
        baseAtk: clamp(Math.round(meanAtk * 1.45), 2400, 5200),
        atk: 0,
        baseN: 20,
        n: 20,
        power: 0.97,
        attacksMade: 0,
        maxAttacks: 2,
        summoningSick: true,
        hasJobRelevance: false,
        hasImputation: false,
        hasPHacking: false,
        hasPracticeEffect: false,
        correctionApplied: false,
        rangeRestrictionStacks: 0,
        validityMultiplier: 1,
        isMeta: true
    };
}
function finalizeMetaMonster(m) {
    m.atk = m.baseAtk;
    m.power = clamp(0.9 + (m.n / 1000), 0.9, 0.99);
    return m;
}
function logLocal(msg, type='info-log') {
    if (!localGame) return;
    localGame.log.push({ msg, type });
}
function markGameOverIfNeeded() {
    if (!localGame || localGame.status === 'finished') return;
    const p1 = localGame.players[1], p2 = localGame.players[2];
    if (p1.lp <= 0 || p2.lp <= 0) {
        localGame.status = 'finished';
        localGame.winner = p1.lp > 0 ? 1 : 2;
        logLocal(`P${localGame.winner} wins the duel!`, 'meta-log');
    }
}
function maybeDeckOutDamage(player, pid) {
    if (player.deck.length === 0 && player.hand.length === 0) {
        player.lp = Math.max(0, player.lp - 500);
        logLocal(`P${pid} suffers 500 LP fatigue (empty deck and hand).`, 'error-log');
        markGameOverIfNeeded();
    }
}
function startTurnFor(pid) {
    const p = localGame.players[pid];
    p.summoned = false;
    drawCards(p, 1);
    p.monsters.forEach(m => {
        if (m) {
            m.summoningSick = false;
            m.attacksMade = 0;
            m.maxAttacks = m.isMeta ? 2 : 1;
            refreshMonsterStats(m);
        }
    });
    logLocal(`P${pid} draws a card.`, 'info-log');
    maybeDeckOutDamage(p, pid);
}

function chooseAIMulliganIndices(hand) {
    const replace = [];
    const replaceSet = new Set();

    const mark = (i) => { if (!replaceSet.has(i)) { replaceSet.add(i); replace.push(i); } };

    // Toss situational/reactive cards in opening hand more often
    hand.forEach((c, i) => {
        if (!c.isItem && ['missing_data', 'range_restrict', 'construct_drift', 'criterion_contam', 'correction'].includes(c.id)) {
            mark(i);
        }
    });

    // Trim duplicates beyond 2 of the same construct in opener
    const byConstruct = {};
    hand.forEach((c, i) => {
        if (!c.isItem) return;
        byConstruct[c.constructId] ||= [];
        byConstruct[c.constructId].push(i);
    });
    Object.values(byConstruct).forEach(arr => {
        while (arr.length > 2) mark(arr.pop());
    });

    // If still missing predictor or outcome after provisional keeps, mulligan more non-items to dig
    const keptHasPred = hand.some((c, i) => c.isItem && c.type === 'predictor' && !replaceSet.has(i));
    const keptHasOut  = hand.some((c, i) => c.isItem && c.type === 'outcome' && !replaceSet.has(i));
    if (!keptHasPred || !keptHasOut) {
        hand.forEach((c, i) => {
            if (replace.length >= 5) return;
            if (!c.isItem && !replaceSet.has(i)) mark(i);
        });
    }

    return replace.slice(0, 5);
}

function localMulligan(pid, indices = []) {
    if (!localGame || localGame.status === 'finished') return { success: false, message: 'Game not active' };
    if (!localGame.mulligan?.phase) return { success: false, message: 'Mulligan phase is over' };
    if (localGame.mulligan.done?.[pid]) return { success: false, message: 'Mulligan already completed' };

    const p = localGame.players[pid];
    const uniq = [...new Set(indices)]
        .filter(i => Number.isInteger(i) && i >= 0 && i < p.hand.length)
        .sort((a, b) => b - a);

    const replacedCards = [];
    uniq.forEach(i => {
        const [card] = p.hand.splice(i, 1);
        if (card) replacedCards.push(card);
    });

    if (replacedCards.length) {
        p.deck.push(...replacedCards.map(c => deepClone(c)));
        shuffle(p.deck);
        drawCards(p, replacedCards.length);
    }

    localGame.mulligan.done[pid] = true;
    logLocal(`P${pid} completes mulligan (${replacedCards.length} card${replacedCards.length === 1 ? '' : 's'} replaced).`, 'info-log');

    if (localGame.mulligan.done[1] && localGame.mulligan.done[2]) {
        localGame.mulligan.phase = false;
        logLocal(`Mulligans complete. P1 begins the duel.`, 'meta-log');
    }

    return { success: true };
}

async function localSubmitMulligan(indices) {
    const out = localMulligan(1, indices);
    if (!out.success) return { success: false, message: out.message };
    return { success: true, state: projectStateForPlayer(1) };
}

function initLocalGame() {
    localGame = {
        status: 'active',
        currentPlayer: 1,
        winner: null,
        log: [],
        mulligan: { phase: true, done: { 1: false, 2: false } },
        players: {
            1: { lp: 8000, deck: buildStartingDeck(), hand: [], constructs: [null, null, null], monsters: [null, null, null], summoned: false },
            2: { lp: 8000, deck: buildStartingDeck(), hand: [], constructs: [null, null, null], monsters: [null, null, null], summoned: false }
        }
    };

    drawCards(localGame.players[1], STARTING_HAND_SIZE);
    drawCards(localGame.players[2], STARTING_HAND_SIZE);

    const aiMull = chooseAIMulliganIndices(localGame.players[2].hand);
    localMulligan(2, aiMull);

    const aiProfile = getAIProfile();
    logLocal(`Single-player mode started. You are P1. ${aiProfile.label} AI is P2.`, 'meta-log');
    logLocal(`Opening hands drawn (${STARTING_HAND_SIZE}). Select any cards to mulligan before turn 1.`, 'info-log');
}
function projectStateForPlayer(pid) {
    const me = localGame.players[pid];
    const opp = localGame.players[pid === 1 ? 2 : 1];
    return {
        status: localGame.status,
        i_won: localGame.status === 'finished' ? localGame.winner === pid : false,
        is_my_turn: localGame.currentPlayer === pid,
        my_lp: me.lp,
        opp_lp: opp.lp,
        my_hand: deepClone(me.hand),
        opp_hand_count: opp.hand.length,
        my_deck_count: me.deck.length,
        my_constructs: deepClone(me.constructs),
        opp_constructs: deepClone(opp.constructs),
        my_monsters: deepClone(me.monsters),
        opp_monsters: deepClone(opp.monsters),
        my_summoned: me.summoned,
        mulligan_pending: !!(localGame.mulligan?.phase && !localGame.mulligan.done[pid]),
        mulligan_done: !!(localGame.mulligan?.done?.[pid]),
        log: deepClone(localGame.log)
    };
}
function consumeAttackSample(monster) {
    if (!monster) return;
    if (monster.hasPracticeEffect) monster.validityMultiplier = Math.max(0.03125, (monster.validityMultiplier ?? 1) / 2);
    monster.n = monster.baseN ?? 20;
    if (!monster.isMeta) {
        refreshMonsterStats(monster);
    } else {
        monster.power = clamp(0.9 + (monster.n / 1200), 0.9, 0.99);
    }
}
function localCanMeta(player) {
    const m = player.monsters;
    if (!(m[0] && m[1] && m[2])) return false;
    const samePred = m.every(x => x.predId === m[0].predId && x.predId !== 'META');
    const sameOut = m.every(x => x.outId === m[0].outId && x.outId !== 'META');
    return samePred || sameOut;
}
function localAttackResolution(attacker, defender) {
    if (!defender) return { damage: attacker.atk, outcome: 'win', destroyAttacker: false, destroyDefender: false };
    if (attacker.atk > defender.atk) return { damage: attacker.atk - defender.atk, outcome: 'win', destroyAttacker: false, destroyDefender: true };
    if (attacker.atk < defender.atk) return { damage: defender.atk - attacker.atk, outcome: 'lose', destroyAttacker: true, destroyDefender: false };
    return { damage: 0, outcome: 'tie', destroyAttacker: true, destroyDefender: true };
}
function canMonsterAttack(monster) {
    if (!monster || monster.summoningSick || monster.attacksMade >= monster.maxAttacks) return false;
    if (monster.requiresJobRelevance && !monster.hasJobRelevance) return false;
    return true;
}

function applyLocalMove(pid, move) {
    if (!localGame) return { success: false, message: 'Local game not initialized' };
    if (localGame.status === 'finished') return { success: false, message: 'Game already finished' };
    if (localGame.currentPlayer !== pid) return { success: false, message: 'Not your turn' };
    if (localGame.mulligan?.phase) return { success: false, message: 'Complete mulligan first' };

    const me = localGame.players[pid];
    const opp = localGame.players[pid === 1 ? 2 : 1];
    let move_result = null;

    const removeHandCard = (idx) => {
        if (idx < 0 || idx >= me.hand.length) return null;
        return me.hand.splice(idx, 1)[0];
    };

    if (move.type === 'place_card') {
        const card = me.hand[move.hand_index];
        if (!card || !card.isItem) return { success: false, message: 'Select a construct item card' };
        const slotIdx = move.slot;
        if (slotIdx < 0 || slotIdx > 2) return { success: false, message: 'Invalid slot' };
        const existing = me.constructs[slotIdx];
        if (existing && existing.constructId !== card.constructId) return { success: false, message: 'Slot contains a different construct' };
        if (existing && existing.cards.length >= 3) return { success: false, message: 'Construct stack is already at 3 items' };
        const placed = removeHandCard(move.hand_index);
        if (!existing) me.constructs[slotIdx] = makeConstructStackFromCard(placed);
        else existing.cards.push(deepClone(placed));
        const stack = me.constructs[slotIdx];
        logLocal(`P${pid} places ${placed.construct} (${stack.cards.length}/3) in construct slot ${slotIdx + 1}.`, 'formula-log');
    }
    else if (move.type === 'summon') {
        if (me.summoned) return { success: false, message: 'You can only summon once per turn' };

        const mSlot = firstEmptySlot(me.monsters);
        if (mSlot === -1) return { success: false, message: 'No empty monster slot' };

        if (move.pred_slot === move.out_slot) {
            return { success: false, message: 'Predictor and Outcome must be different slots' };
        }

        const pred = me.constructs[move.pred_slot];
        const out = me.constructs[move.out_slot];

        if (!pred || pred.type !== 'predictor') return { success: false, message: 'Choose a predictor construct' };
        if (!out || out.type !== 'outcome') return { success: false, message: 'Choose an outcome construct' };

        const monster = buildMonster(pred, out);

        me.constructs[move.pred_slot] = null;
        me.constructs[move.out_slot] = null;

        me.monsters[mSlot] = monster;
        me.summoned = true;

        logLocal(
            `P${pid} summons ${monster.name} (ATK ${monster.atk}, PWR ${Math.floor(monster.power * 100)}%) by consuming construct materials.`,
            'formula-log'
        );
    }
    else if (move.type === 'play_spell') {
        const card = me.hand[move.hand_index];
        if (!card || card.isItem) return { success: false, message: 'Select a spell/trap/resource card' };
        const targetPlayer = move.target_owner === 'opp' ? opp : me;
        const targetPid = move.target_owner === 'opp' ? (pid === 1 ? 2 : 1) : pid;
        const targetArr = move.target_type === 'construct' ? targetPlayer.constructs : targetPlayer.monsters;
        const target = targetArr[move.target_slot];
        if (!target) return { success: false, message: 'No valid target there' };

        removeHandCard(move.hand_index);

        if (card.id === 'sample_size') {
            if (move.target_type !== 'monster') return { success: false, message: 'Sample Size must target a monster' };
            target.n = clamp(target.n + 100, 20, 420);
            if (!target.isMeta) refreshMonsterStats(target);
            else target.power = clamp(target.power + 0.01, 0.9, 0.99);
            logLocal(`P${pid} plays Sample Size on P${targetPid}'s monster (N = ${target.n}, PWR ${Math.floor(target.power * 100)}%).`, 'spell-log');
        }
        else if (card.id === 'job_relevance') {
            if (move.target_type !== 'monster' || targetPlayer !== me) return { success: false, message: 'Job Relevance must target your monster' };
            if (!target.requiresJobRelevance) return { success: false, message: 'This monster does not need Job Relevance to attack' };
            if (target.hasJobRelevance) return { success: false, message: 'Job Relevance is already equipped to this monster' };
            target.hasJobRelevance = true;
            logLocal(`P${pid} equips Job Relevance to ${target.name}. It can now attack while it remains on the field.`, 'spell-log');
        }
        else if (card.id === 'imputation') {
            if (move.target_type !== 'monster' || targetPlayer !== me) return { success: false, message: 'Imputation must target your monster' };
            if (target.hasImputation) return { success: false, message: 'Imputation is already equipped to this monster' };
            target.hasImputation = true;
            logLocal(`P${pid} equips Imputation to ${target.name}. Missing Data will remove Imputation first.`, 'spell-log');
        }
        else if (card.id === 'p_hacking') {
            if (move.target_type !== 'monster' || targetPlayer !== me) return { success: false, message: 'P-hacking must target your monster' };
            if (target.hasPHacking) return { success: false, message: 'P-hacking is already equipped to this monster' };
            target.hasPHacking = true;
            logLocal(`P${pid} equips P-hacking to ${target.name}. Its next attack cannot miss, but it will be destroyed after attacking.`, 'spell-log');
        }
        else if (card.id === 'practice_effect') {
            if (move.target_type !== 'monster') return { success: false, message: 'Practice Effect must target a monster' };
            if (target.hasPracticeEffect) return { success: false, message: 'Practice Effect is already equipped to this monster' };
            target.hasPracticeEffect = true;
            logLocal(`P${pid} equips Practice Effect to ${target.name}. Each attack halves its current validity coefficient.`, 'spell-log');
        }
        else if (card.id === 'missing_data') {
            if (move.target_type === 'construct') {
                const destroyed = targetArr[move.target_slot];
                targetArr[move.target_slot] = null;
                logLocal(`P${pid} plays Missing Data and destroys P${targetPid}'s ${destroyed.cards[0].construct} construct stack.`, 'spell-log');
            } else {
                const destroyed = targetArr[move.target_slot];
                if (destroyed.hasImputation) {
                    destroyed.hasImputation = false;
                    logLocal(`P${pid} plays Missing Data on P${targetPid}'s ${destroyed.name}, but Imputation is destroyed instead.`, 'spell-log');
                } else {
                    targetArr[move.target_slot] = null;
                    logLocal(`P${pid} plays Missing Data and destroys P${targetPid}'s monster ${destroyed.name}.`, 'spell-log');
                }
            }
        }
        else if (card.id === 'range_restrict') {
            if (move.target_type !== 'monster' || targetPlayer !== opp) return { success: false, message: 'Range Restriction must target an enemy monster' };
            target.rangeRestrictionStacks = Math.max(0, target.rangeRestrictionStacks ?? 0) + 1;
            refreshMonsterStats(target);
            logLocal(`P${pid} applies Range Restriction to ${target.name}. (${target.rangeRestrictionStacks} stack${target.rangeRestrictionStacks === 1 ? '' : 's'}) ATK reduced to ${target.atk}.`, 'spell-log');
        }
        else if (card.id === 'correction') {
            if (move.target_type !== 'monster' || targetPlayer !== me) return { success: false, message: 'Correction for Attenuation must target your monster' };
            target.correctionApplied = true;
            target.rangeRestrictionStacks = 0;
            refreshMonsterStats(target);
            target.atk = Math.round(Math.abs(target.rTrue ?? 0) * Math.max(0, target.validityMultiplier ?? 1) * 10000);
            logLocal(`P${pid} applies Correction for Attenuation to ${target.name}. ATK ${target.atk}, PWR ${Math.floor(target.power * 100)}%.`, 'spell-log');
        }
        else if (card.id === 'bootstrapping') {
            if (move.target_type !== 'monster' || targetPlayer !== me) return { success: false, message: 'Bootstrapping must target your monster' };
            target.baseN = (target.baseN ?? 20) + 30;
            target.n = (target.n ?? 20) + 30;
            if (!target.isMeta) refreshMonsterStats(target);
            else target.power = clamp(0.9 + (target.n / 1200), 0.9, 0.99);
            logLocal(`P${pid} plays Bootstrapping on ${target.name}. Base N is now ${target.baseN}.`, 'spell-log');
        }
        else if (card.id === 'item_analysis') {
            if (move.target_type !== 'construct' || targetPlayer !== me) return { success: false, message: 'Automated Item Generation must target your construct stack' };
            if (target.cards.length >= 3) return { success: false, message: 'Construct stack already at maximum size' };
            target.cards.push(deepClone(target.cards[target.cards.length - 1]));
            logLocal(`P${pid} plays Automated Item Generation on ${target.cards[0].construct}. Stack grows to ${target.cards.length}.`, 'spell-log');
        }
        else if (card.id === 'construct_drift') {
            if (move.target_type !== 'construct' || targetPlayer !== opp) return { success: false, message: 'Construct Drift must target an enemy construct' };
            const driftedName = target.cards[0].construct;
            if (target.cards.length > 1) {
                target.cards.pop();
                logLocal(`P${pid} applies Construct Drift to ${driftedName}. Enemy stack drops to ${target.cards.length}.`, 'spell-log');
            } else {
                targetArr[move.target_slot] = null;
                logLocal(`P${pid} applies Construct Drift and collapses enemy ${driftedName} construct stack.`, 'spell-log');
            }
        }
        else if (card.id === 'criterion_contam') {
            if (move.target_type !== 'monster' || targetPlayer !== opp) return { success: false, message: 'Attrition must target an enemy monster' };
            target.n = Math.max(1, Math.floor(target.n / 2));
            target.baseN = Math.max(1, Math.floor((target.baseN ?? 20) / 2));
            if (!target.isMeta) refreshMonsterStats(target);
            else target.power = clamp(0.9 + (target.n / 1200), 0.9, 0.99);
            logLocal(`P${pid} applies Attrition to ${target.name}. Base N is now ${target.baseN}.`, 'spell-log');
        }
        else {
            return { success: false, message: 'Unknown card effect' };
        }
    }
    else if (move.type === 'attack') {
        const attacker = me.monsters[move.attacker_slot];
        if (!attacker) return { success: false, message: 'No attacker in that slot' };
        if (attacker.summoningSick) return { success: false, message: 'This monster cannot attack the turn it was summoned' };
        if (attacker.requiresJobRelevance && !attacker.hasJobRelevance) return { success: false, message: 'This monster needs Job Relevance equipped to attack' };
        if (attacker.attacksMade >= attacker.maxAttacks) return { success: false, message: 'This monster has no attacks left' };

        const threshold = clamp(Math.round(attacker.power * 20), 1, 20);
        const roll = randInt(1, 20);
        const isPHackingAttack = !!attacker.hasPHacking;
        const hit = isPHackingAttack || roll <= threshold;
        move_result = { roll, threshold, hit, attack_data: { damage: 0, outcome: 'tie' } };

        attacker.attacksMade += 1;

        if (!hit) {
            logLocal(`P${pid}'s ${attacker.name} attacks and rolls ${roll} (needs ‚â§ ${threshold}). Type II error ‚Äî attack misses.`, 'battle-log');
            consumeAttackSample(attacker);
        } else {
            if (move.target_type === 'lp') {
                const dmg = attacker.atk;
                opp.lp = Math.max(0, opp.lp - dmg);
                move_result.attack_data = { damage: dmg, outcome: 'win' };
                logLocal(`P${pid}'s ${attacker.name} attacks directly for ${dmg} LP damage!`, 'battle-log');
                consumeAttackSample(attacker);
            } else {
                const defender = opp.monsters[move.target_slot];
                if (!defender) {
                    logLocal(`P${pid}'s attack fizzles: target no longer exists.`, 'error-log');
                    consumeAttackSample(attacker);
                } else {
                    const outcome = localAttackResolution(attacker, defender);
                    if (outcome.outcome === 'win') {
                        if (outcome.destroyDefender) opp.monsters[move.target_slot] = null;
                        if (outcome.damage > 0) opp.lp = Math.max(0, opp.lp - outcome.damage);
                        logLocal(`P${pid}'s ${attacker.name} defeats ${defender.name}${outcome.damage > 0 ? ` and deals ${outcome.damage} LP damage` : ''}.`, 'battle-log');
                    } else if (outcome.outcome === 'lose') {
                        if (outcome.destroyAttacker) me.monsters[move.attacker_slot] = null;
                        if (outcome.damage > 0) me.lp = Math.max(0, me.lp - outcome.damage);
                        logLocal(`P${pid}'s ${attacker.name} loses to ${defender.name}${outcome.damage > 0 ? ` and P${pid} takes ${outcome.damage} LP damage` : ''}.`, 'battle-log');
                    } else {
                        if (outcome.destroyAttacker) me.monsters[move.attacker_slot] = null;
                        if (outcome.destroyDefender) opp.monsters[move.target_slot] = null;
                        logLocal(`P${pid}'s ${attacker.name} and ${defender.name} destroy each other.`, 'battle-log');
                    }
                    move_result.attack_data = { damage: outcome.damage, outcome: outcome.outcome };
                    if (me.monsters[move.attacker_slot]) consumeAttackSample(me.monsters[move.attacker_slot]);
                }
            }
        }

        if (isPHackingAttack && me.monsters[move.attacker_slot]) {
            const doomedName = me.monsters[move.attacker_slot].name;
            me.monsters[move.attacker_slot] = null;
            logLocal(`P${pid}'s ${doomedName} is destroyed by P-hacking after attacking.`, 'battle-log');
        }
        markGameOverIfNeeded();
    }
    else if (move.type === 'meta') {
        if (!localCanMeta(me)) return { success: false, message: 'Need 3 monsters sharing the same Predictor or Outcome' };
        const mats = me.monsters.filter(Boolean);
        me.monsters = [null, null, null];
        const meta = finalizeMetaMonster(buildMetaMonster(mats));
        me.monsters[0] = meta;
        move_result = { meta: true };
        logLocal(`P${pid} performs META-ANALYSIS and summons ${meta.name}! (ATK ${meta.atk}, PWR ${Math.floor(meta.power * 100)}%)`, 'meta-log');
    }
    else if (move.type === 'end_turn') {
        const nextPid = pid === 1 ? 2 : 1;
        localGame.currentPlayer = nextPid;
        startTurnFor(nextPid);
        logLocal(`P${pid} ends turn.`, 'info-log');
    }
    else {
        return { success: false, message: 'Unknown move type' };
    }

    markGameOverIfNeeded();
    return { success: true, move_result };
}


function enumerateCandidateMoves(state, pid) {
    const p = state.players[pid];
    const moves = [];

    p.hand.forEach((card, hand_index) => {
        if (card.isItem) {
            for (let slot = 0; slot < 3; slot++) {
                const stack = p.constructs[slot];
                if (stack && stack.constructId !== card.constructId) continue;
                if (stack && stack.cards.length >= 3) continue;
                moves.push({ type: 'place_card', hand_index, slot });
            }
        } else {
            if (card.id === 'sample_size' || card.id === 'job_relevance' || card.id === 'imputation' || card.id === 'p_hacking' || card.id === 'practice_effect' || card.id === 'range_restrict' || card.id === 'correction' || card.id === 'item_analysis' || card.id === 'bootstrapping' || card.id === 'criterion_contam') {
                ['me', 'opp'].forEach(target_owner => {
                    const targetMonsters = state.players[target_owner === 'me' ? pid : (pid === 1 ? 2 : 1)].monsters;
                    targetMonsters.forEach((m, target_slot) => {
                        if (m) moves.push({ type: 'play_spell', hand_index, target_owner, target_type: 'monster', target_slot });
                    });
                });
            }
            if (card.id === 'missing_data' || card.id === 'construct_drift') {
                ['me', 'opp'].forEach(target_owner => {
                    const targetConstructs = state.players[target_owner === 'me' ? pid : (pid === 1 ? 2 : 1)].constructs;
                    targetConstructs.forEach((c, target_slot) => {
                        if (c) moves.push({ type: 'play_spell', hand_index, target_owner, target_type: 'construct', target_slot });
                    });
                });
            }
        }
    });

    if (!p.summoned && firstEmptySlot(p.monsters) !== -1) {
        for (let pred_slot = 0; pred_slot < 3; pred_slot++) {
            for (let out_slot = 0; out_slot < 3; out_slot++) {
                moves.push({ type: 'summon', pred_slot, out_slot });
            }
        }
    }

    if (localCanMeta(p)) moves.push({ type: 'meta' });

    p.monsters.forEach((m, attacker_slot) => {
        if (!canMonsterAttack(m)) return;
        moves.push({ type: 'attack', attacker_slot, target_type: 'lp', target_slot: null });
        const opp = state.players[pid === 1 ? 2 : 1];
        opp.monsters.forEach((target, target_slot) => {
            if (target) moves.push({ type: 'attack', attacker_slot, target_type: 'monster', target_slot });
        });
    });

    moves.push({ type: 'end_turn' });
    return moves;
}

function simulateLocalMove(state, pid, move) {
    const snapshot = localGame;
    localGame = deepClone(state);
    const out = applyLocalMove(pid, move);
    const result = { success: out.success, state: deepClone(localGame) };
    localGame = snapshot;
    return result;
}

function evaluateLocalState(state, pid) {
    const me = state.players[pid];
    const opp = state.players[pid === 1 ? 2 : 1];
    const myAtk = me.monsters.reduce((sum, m) => sum + (m ? (m.atk * (m.power || 0.5)) : 0), 0);
    const oppAtk = opp.monsters.reduce((sum, m) => sum + (m ? (m.atk * (m.power || 0.5)) : 0), 0);
    const myConstructs = me.constructs.reduce((sum, c) => sum + (c ? c.cards.length : 0), 0);
    const oppConstructs = opp.constructs.reduce((sum, c) => sum + (c ? c.cards.length : 0), 0);
    let score = (me.lp - opp.lp) + (myAtk - oppAtk) * 0.9 + (myConstructs - oppConstructs) * 120 + (me.hand.length - opp.hand.length) * 45;
    if (state.status === 'finished') score += state.winner === pid ? 20000 : -20000;
    return score;
}

let localAIBrain = null;
function getLocalAIBrain() {
    if (localAIBrain) return localAIBrain;
    localAIBrain = window.PsychometricDuelMctsAI.createController({
        getDifficulty: () => session?.aiDifficulty || 'strong',
        getState: () => localGame,
        enumerateMoves: (state, pid) => enumerateCandidateMoves(state, pid)
            .filter(move => simulateLocalMove(state, pid, move).success),
        simulateMove: simulateLocalMove,
        evaluateState: evaluateLocalState,
        applyMove: (pid, move) => applyLocalMove(pid, move)
    });
    return localAIBrain;
}

async function runSinglePlayerAI() {
    if (!localGame || localGame.status !== 'active') return;
    if (localGame.currentPlayer !== 2) return;
    await getLocalAIBrain().playTurn(2);
}

async function localSubmitMove(move) {
    const out = applyLocalMove(1, move);
    if (!out.success) return { success: false, message: out.message };
    if (move.type === 'end_turn' && localGame.status === 'active') {
        await runSinglePlayerAI();
    }
    return { success: true, state: projectStateForPlayer(1), move_result: out.move_result };
}
function startSinglePlayer() {
    clearInterval(session.pollTimer);
    session.gameMode = 'single';
    session.roomCode = 'LOCAL-AI';
    session.playerToken = 'LOCAL';
    session.playerNum = 1;
    lastLogCount = 0;
    gameOver = false;
    selectedHandCard = null;
    summonPredSlot = null;
    attackingMonsterSlot = null;
    mulliganSelection = new Set();
    uiPhase = 'idle';
    localAIBrain = null;
    initLocalGame();
    gs = projectStateForPlayer(1);
    startGame();
}

// ==================== SESSION STATE ====================
let session = {
    roomCode: null,
    playerToken: null,
    playerNum: null,
    pollTimer: null,
    gameMode: 'online',
    aiDifficulty: 'strong'
};

// Local mirror of the filtered server state
let gs = null; // game state from server
let uiPhase = 'idle'; // local UI phase for selection
let selectedHandCard = null;
let summonPredSlot = null;
let attackingMonsterSlot = null;
let gameOver = false;
let lastLogCount = 0;
let mulliganSelection = new Set();

// ==================== API CALLS ====================
async function apiCall(body) {
    try {
        const res = await fetch(API_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body)
        });
        return await res.json();
    } catch (e) {
        console.error('API error:', e);
        return { success: false, message: 'Network error' };
    }
}

// ==================== LOBBY ====================
async function createRoom() {
    session.gameMode = 'online';
    const res = await apiCall({ action: 'create_room' });
    if (!res.success) { alert(res.message); return; }
    session.roomCode = res.room_code;
    session.playerToken = res.player_token;
    session.playerNum = res.player_num;

    document.getElementById('main-menu').style.display = 'none';
    document.getElementById('single-menu').style.display = 'none';
    document.getElementById('lobby-menu').style.display = 'none';
    document.getElementById('lobby-waiting').style.display = 'flex';
    document.getElementById('room-code-display').textContent = res.room_code;

    startLobbyPolling();
}

async function joinRoom() {
    session.gameMode = 'online';
    const code = document.getElementById('join-code-input').value.trim().toUpperCase();
    if (code.length !== 10) { alert('Enter a valid 10-character room code'); return; }

    const res = await apiCall({ action: 'join_room', room_code: code });
    if (!res.success) { alert(res.message); return; }
    session.roomCode = res.room_code;
    session.playerToken = res.player_token;
    session.playerNum = res.player_num;

    startGame();
}

function copyRoomCode() {
    navigator.clipboard?.writeText(session.roomCode);
    document.getElementById('lobby-status').textContent = 'Code copied!';
    setTimeout(() => { document.getElementById('lobby-status').textContent = 'Waiting for opponent...'; }, 1500);
}

function startLobbyPolling() {
    session.pollTimer = setInterval(async () => {
        const res = await apiCall({ action: 'poll', room_code: session.roomCode, player_token: session.playerToken });
        if (res.success && res.state && res.state.status === 'active') {
            clearInterval(session.pollTimer);
            startGame();
        }
    }, 1500);
}

// ==================== GAME START ====================
function startGame() {
    document.getElementById('title-screen').style.display = 'none';
    document.getElementById('game-screen').classList.add('active');
    startGamePolling();
}

function startGamePolling() {
    pollNow();
    if (session.gameMode === 'single') return;
    session.pollTimer = setInterval(pollNow, 2000);
}

async function pollNow() {
    if (session.gameMode === 'single') {
        if (!localGame) return;
        gs = projectStateForPlayer(session.playerNum || 1);
        if (gs.log && gs.log.length > lastLogCount) {
            for (let i = lastLogCount; i < gs.log.length; i++) {
                addLog(gs.log[i].msg, gs.log[i].type);
            }
            lastLogCount = gs.log.length;
        }
        if (gs.status === 'finished' && !gameOver) {
            gameOver = true;
            endGame(gs.i_won);
        }
        renderAll();
        return;
    }

    const res = await apiCall({ action: 'poll', room_code: session.roomCode, player_token: session.playerToken });
    if (!res.success) return;
    gs = res.state;

    if (gs.log && gs.log.length > lastLogCount) {
        for (let i = lastLogCount; i < gs.log.length; i++) {
            addLog(gs.log[i].msg, gs.log[i].type);
        }
        lastLogCount = gs.log.length;
    }

    if (gs.status === 'finished' && !gameOver) {
        gameOver = true;
        endGame(gs.i_won);
    }

    renderAll();
}

// ==================== SUBMIT MOVE ====================
async function submitMove(move, skipRender = false) {
    const res = session.gameMode === 'single'
        ? await localSubmitMove(move)
        : await apiCall({
            action: 'submit_move',
            room_code: session.roomCode,
            player_token: session.playerToken,
            move: move
        });

    if (!res.success) {
        addLog('Error: ' + res.message, 'error-log');
        return res;
    }

    if (!skipRender) {
        gs = res.state;

        if (gs.log && gs.log.length > lastLogCount) {
            for (let i = lastLogCount; i < gs.log.length; i++) {
                addLog(gs.log[i].msg, gs.log[i].type);
            }
            lastLogCount = gs.log.length;
        }

        if (gs.status === 'finished' && !gameOver) {
            gameOver = true;
            endGame(gs.i_won);
        }

        renderAll();
    }
    return res;
}

// ==================== RENDERING ====================
function renderCard(card, idx, inHand) {
    const div = document.createElement('div');
    div.className = `card ${card.type}` + (selectedHandCard === idx && inHand ? ' selected' : '');
    if (inHand) div.onclick = () => selectHandCard(idx);

    if (card.isItem) {
        div.innerHTML = `
            <div class="card-type-badge">${card.type === 'predictor' ? '‚¨¢ PREDICTOR' : '‚óÜ OUTCOME'}</div>
            <div class="card-construct">${card.sprite} ${card.short}</div>
            <div class="card-indicator">${card.indicator}</div>
            <div class="card-stats"><span>rÃÑ=${card.avgR.toFixed(2)}</span></div>
        `;
    } else {
        div.innerHTML = `
            <div class="card-type-badge">${card.type.toUpperCase()}</div>
            <div class="card-construct">${card.icon}</div>
            <div class="card-indicator" style="font-size:0.8cqmin;">${card.name}</div>
        `;
    }
    div.onmouseenter = (e) => showCardTooltip(e, card);
    div.onmouseleave = hideTooltip;
    return div;
}

function renderConstructSlot(slotIdx, owner) {
    const constructs = owner === 'player' ? gs.my_constructs : gs.opp_constructs;
    const prefix = owner === 'player' ? 'player' : 'opp';
    const slot = document.getElementById(`${prefix}-construct-${slotIdx}`);
    slot.innerHTML = '';
    slot.className = 'card-slot';
    const c = constructs[slotIdx];

    if (uiPhase === 'spell_target_missing_data' && c) {
        slot.classList.add('spell-target');
        slot.onclick = () => executeMissingData(slotIdx, owner, 'construct');
    } else if (uiPhase === 'spell_target_item_analysis' && owner === 'player' && c && c.cards.length < 3) {
        slot.classList.add('spell-target');
        slot.onclick = () => executeItemAnalysis(slotIdx);
    } else if (uiPhase === 'spell_target_construct_drift' && owner === 'opp' && c) {
        slot.classList.add('spell-target');
        slot.onclick = () => executeConstructDrift(slotIdx);
    } else {
        slot.onclick = owner === 'player' ? () => onConstructSlotClick(slotIdx) : null;
    }

    if (!c) return;
    const k = c.cards.length;
    const rel = spearmanBrown(k, c.cards[0].avgR);
    const topCard = c.cards[k - 1];
    const div = document.createElement('div');
    div.className = `card ${topCard.type}`;
    div.style.cursor = 'pointer';
    div.innerHTML = `
        <div class="card-type-badge">${topCard.type === 'predictor' ? '‚¨¢ PRED' : '‚óÜ OUT'}</div>
        <div class="card-construct">${topCard.sprite} ${topCard.short}</div>
        <div class="card-indicator" style="font-size:0.7cqmin;">Œ± = ${rel.toFixed(2)}</div>
    `;
    if (k > 1) div.innerHTML += `<div class="stack-count">√ó${k}</div>`;
    div.onmouseenter = (e) => showConstructTooltip(e, c);
    div.onmouseleave = hideTooltip;
    slot.appendChild(div);
}

function renderMonsterSlot(slotIdx, owner) {
    const monsters = owner === 'player' ? gs.my_monsters : gs.opp_monsters;
    const prefix = owner === 'player' ? 'player' : 'opp';
    const slot = document.getElementById(`${prefix}-monster-${slotIdx}`);
    slot.innerHTML = '';
    slot.className = 'card-slot';
    const m = monsters[slotIdx];

    if (m) ensureMonsterFlavor(m);

    // Spell targeting highlights
    if (uiPhase === 'spell_target_range' && owner === 'opp' && m) {
        slot.classList.add('spell-target');
        slot.onclick = () => executeRangeRestrict(slotIdx);
    } else if (uiPhase === 'spell_target_practice_effect' && owner === 'opp' && m) {
        slot.classList.add('spell-target');
        slot.onclick = () => executePracticeEffect(slotIdx, 'opp');
    } else if (uiPhase === 'spell_target_criterion_contam' && owner === 'opp' && m) {
        slot.classList.add('spell-target');
        slot.onclick = () => executeCriterionContam(slotIdx);
    } else if (uiPhase === 'spell_target_correct' && owner === 'player' && m && !m.isMeta) {
        slot.classList.add('spell-target');
        slot.onclick = () => executeCorrection(slotIdx);
    } else if (uiPhase === 'spell_target_sample_size' && owner === 'player' && m) {
        slot.classList.add('resource-target');
        slot.onclick = () => executeSampleSize(slotIdx);
    } else if (uiPhase === 'spell_target_bootstrapping' && owner === 'player' && m) {
        slot.classList.add('spell-target');
        slot.onclick = () => executeBootstrapping(slotIdx);
    } else if (uiPhase === 'spell_target_missing_data' && m) {
        slot.classList.add('spell-target');
        slot.onclick = () => executeMissingData(slotIdx, owner, 'monster');
    } else if (uiPhase === 'spell_target_job_relevance' && owner === 'player' && m) {
        slot.classList.add('spell-target');
        slot.onclick = () => executeJobRelevance(slotIdx);
    } else if (uiPhase === 'spell_target_imputation' && owner === 'player' && m) {
        slot.classList.add('spell-target');
        slot.onclick = () => executeImputation(slotIdx);
    } else if (uiPhase === 'spell_target_p_hacking' && owner === 'player' && m) {
        slot.classList.add('spell-target');
        slot.onclick = () => executePHacking(slotIdx);
    } else {
        slot.onclick = null;
    }

    if (!m) return;

    const canAttack = owner === 'player' && canMonsterAttack(m) && uiPhase !== 'attack_select_target' && !uiPhase.startsWith('spell');
    const div = document.createElement('div');
    div.className = 'monster-card' + (canAttack ? ' can-attack' : '');
    if (m.isMeta) div.classList.add('is-meta');
    if (attackingMonsterSlot === slotIdx && owner === 'player') div.classList.add('attacking');

    if (owner === 'player' && uiPhase === 'attack_select_monster' && canMonsterAttack(m)) {
        div.onclick = () => selectAttackingMonster(slotIdx);
    } else if (owner === 'opp' && uiPhase === 'attack_select_target') {
        slot.classList.add('attack-target');
        div.onclick = () => selectAttackTarget('monster', slotIdx);
    }

    let pwrPercent = Math.floor(m.power * 100);
    let pwrColor = pwrPercent < 50 ? '#ff5555' : (pwrPercent < 80 ? '#ffcc00' : '#50fa7b');
    let atkCountHtml = m.maxAttacks > 1 ? `<div style="font-size:0.6cqmin; color:#aaa; text-align:center;">Atks: ${m.maxAttacks - m.attacksMade}</div>` : '';
    let repHtml = '';
    if (m.hasJobRelevance) repHtml += `<span style="color:var(--spell); font-size:0.6cqmin;">[JR]</span>`;
    if (m.hasImputation) repHtml += ` <span style="color:var(--predictor-light); font-size:0.6cqmin;">[IMP]</span>`;
    if (m.hasPHacking) repHtml += ` <span style="color:var(--gold); font-size:0.6cqmin;">[PH]</span>`;
    if (m.hasPracticeEffect) repHtml += ` <span style="color:#cc66ff; font-size:0.6cqmin;">[PE]</span>`;
    const aiStars = m.adverseStarsText || '‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ';
    const relevanceHtml = (m.requiresJobRelevance && !m.hasJobRelevance) ? `<div style="font-size:0.58cqmin; color:#ff5555; text-align:center;">NEEDS JOB RELEVANCE</div>` : '';

    div.innerHTML = `
        <div class="monster-name">${m.name}</div>
        <div class="monster-sprite">${m.sprite}</div>
        <div class="monster-stats-bar">
            <span>ATK ${m.atk}</span>
            <span style="color:#aaa;">N=${m.n} ${repHtml}</span>
        </div>
        <div class="monster-reliability" style="color:${m.isMeta ? 'var(--gold)' : pwrColor}">PWR: ${pwrPercent}% ${m.isMeta?'(META)':''}</div>
        <div style="font-size:0.55cqmin; color:var(--gold); text-align:center;">Fairness ${aiStars}</div>
        ${relevanceHtml}
        ${atkCountHtml}
    `;
    div.onmouseenter = (e) => showMonsterTooltip(e, m);
    div.onmouseleave = hideTooltip;
    slot.appendChild(div);
}

function renderHand() {
    const container = document.getElementById('player-hand');
    container.innerHTML = '';
    if (!gs) return;
    gs.my_hand.forEach((card, i) => container.appendChild(renderCard(card, i, true)));

    const oppContainer = document.getElementById('opp-hand-row');
    oppContainer.innerHTML = '';
    for (let i = 0; i < gs.opp_hand_count; i++) {
        oppContainer.innerHTML += `<div class="card-back"><div style="font-size:2cqmin; color:#555;">?</div></div>`;
    }
}

function isMulliganPending() {
    return !!(gs && gs.mulligan_pending);
}

function renderMulliganHand() {
    const container = document.getElementById('mulligan-hand');
    if (!container) return;
    container.innerHTML = '';
    if (!gs || !isMulliganPending()) return;

    gs.my_hand.forEach((card, i) => {
        const wrap = document.createElement('div');
        wrap.className = 'mulligan-card-wrap' + (mulliganSelection.has(i) ? ' selected' : '');

        const cardEl = renderCard(card, i, false);

        // IMPORTANT: do NOT also bind cardEl.onclick to toggle (causes double toggle via bubbling)
        wrap.onclick = () => toggleMulliganSelect(i);

        wrap.appendChild(cardEl);
        container.appendChild(wrap);
    });

    const countEl = document.getElementById('mulligan-count');
    if (countEl) countEl.textContent = String(mulliganSelection.size);
}

function syncMulliganOverlay() {
    const modal = document.getElementById('mulligan-modal');
    if (!modal) return;

    if (gameOver || !isMulliganPending()) {
        modal.classList.remove('active');
        mulliganSelection.clear();
        return;
    }

    modal.classList.add('active');

    const statusEl = document.getElementById('mulligan-status');
    if (statusEl) {
        statusEl.textContent = `Hand size: ${gs.my_hand.length}/${MAX_HAND_SIZE}. Select any number of cards to replace.`;
    }

    renderMulliganHand();
}

function toggleMulliganSelect(idx) {
    if (!isMulliganPending()) return;
    if (mulliganSelection.has(idx)) mulliganSelection.delete(idx);
    else mulliganSelection.add(idx);
    renderMulliganHand();
}

async function confirmMulligan() {
    if (!isMulliganPending()) return;

    const indices = Array.from(mulliganSelection).sort((a, b) => a - b);
    const res = (session.gameMode === 'single')
        ? await localSubmitMulligan(indices)
        : await apiCall({
            action: 'submit_mulligan', // requires backend support for online mode
            room_code: session.roomCode,
            player_token: session.playerToken,
            replace_indices: indices
        });

    if (!res.success) {
        addLog('Error: ' + (res.message || 'Mulligan failed'), 'error-log');
        return;
    }

    gs = res.state || gs;

    if (gs.log && gs.log.length > lastLogCount) {
        for (let i = lastLogCount; i < gs.log.length; i++) {
            addLog(gs.log[i].msg, gs.log[i].type);
        }
        lastLogCount = gs.log.length;
    }

    mulliganSelection.clear();
    renderAll();
}

function keepOpeningHand() {
    mulliganSelection.clear();
    confirmMulligan();
}

function renderAll() {
    if (!gs) return;
    renderHand();
    for (let i = 0; i < 3; i++) {
        renderConstructSlot(i, 'player');
        renderConstructSlot(i, 'opp');
        renderMonsterSlot(i, 'player');
        renderMonsterSlot(i, 'opp');
    }
    updateLP();
    updateButtons();
    document.getElementById('deck-count').textContent = `DECK: ${gs.my_deck_count}`;

    const ti = document.getElementById('turn-indicator');
    if (gs.is_my_turn) {
        ti.textContent = 'YOUR TURN';
        ti.style.color = 'var(--gold)';
    } else {
        ti.textContent = "OPP'S TURN";
        ti.style.color = 'var(--outcome-light)';
    }

    syncMulliganOverlay();
}

function updateLP() {
    if (!gs) return;
    document.getElementById('player-lp').textContent = gs.my_lp;
    document.getElementById('opp-lp').textContent = gs.opp_lp;
    document.getElementById('player-lp-bar').style.width = `${Math.max(0, (gs.my_lp / 8000) * 100)}%`;
    document.getElementById('opp-lp-bar').style.width = `${Math.max(0, (gs.opp_lp / 8000) * 100)}%`;

    if (uiPhase === 'attack_select_target' && !gs.opp_monsters.some(m => m !== null)) {
        document.querySelector('#opp-lp').parentElement.classList.add('lp-target');
        document.querySelector('#opp-lp').parentElement.onclick = () => selectAttackTarget('lp', null);
    } else {
        document.querySelector('#opp-lp').parentElement.classList.remove('lp-target');
        document.querySelector('#opp-lp').parentElement.onclick = null;
    }
}

function updateButtons() {
    if (!gs) return;
    const mulliganPending = isMulliganPending();
    const isMyTurn = gs.is_my_turn && !gameOver && !mulliganPending;
    const isIdle = uiPhase === 'idle';

    const canSummon = gs.my_constructs.some(c => c?.type === 'predictor') &&
                      gs.my_constructs.some(c => c?.type === 'outcome') &&
                      !gs.my_summoned && gs.my_monsters.some(m => m === null);
    const canAttack = gs.my_monsters.some(m => canMonsterAttack(m));
    const canMeta = getMetaTarget() !== null;

    document.getElementById('btn-summon').disabled = !(isMyTurn && canSummon && isIdle);
    document.getElementById('btn-meta').disabled = !(isMyTurn && canMeta && isIdle);
    document.getElementById('btn-attack').disabled = !(isMyTurn && canAttack && isIdle);
    document.getElementById('btn-end').disabled = !(isMyTurn && isIdle);
    document.getElementById('btn-cancel').style.display = (uiPhase !== 'idle' && isMyTurn) ? 'block' : 'none';
}

function getMetaTarget() {
    if (!gs) return null;
    const m = gs.my_monsters;
    if (m[0] && m[1] && m[2]) {
        if (m[0].predId === m[1].predId && m[1].predId === m[2].predId && m[0].predId !== 'META') return true;
        if (m[0].outId === m[1].outId && m[1].outId === m[2].outId && m[0].outId !== 'META') return true;
    }
    return null;
}

// ==================== VISUAL FX ====================
function triggerScreenShake() {
    const c = document.getElementById('game-container');
    c.classList.remove('shake-anim'); void c.offsetWidth; c.classList.add('shake-anim');
}
function triggerFlash(type) {
    const o = document.getElementById('flash-overlay');
    o.className = ''; void o.offsetWidth; o.classList.add(`flash-${type}`);
}
function addLog(msg, type = '') {
    const logEl = document.getElementById('game-log');
    const entry = document.createElement('div');
    entry.className = `log-entry ${type}`;
    let display = msg;
    display = display.replace(new RegExp(`P${session.playerNum}`, 'g'), 'You');
    display = display.replace(new RegExp(`P${session.playerNum === 1 ? 2 : 1}`, 'g'), 'Opponent');
    entry.innerHTML = display;
    logEl.appendChild(entry);
    logEl.scrollTop = logEl.scrollHeight;
}
function showDamageNumber(elId, amount) {
    const el = document.getElementById(elId);
    if (!el) return;
    const rect = el.getBoundingClientRect();
    const dmg = document.createElement('div');
    dmg.className = 'damage-number'; dmg.textContent = `-${amount}`;
    dmg.style.left = `${rect.left}px`; dmg.style.top = `${rect.top + 20}px`;
    document.body.appendChild(dmg);
    setTimeout(() => dmg.remove(), 1500);
}

// ==================== DICE ANIMATION ====================
function showDiceRoll(roll, threshold, hit) {
    return new Promise(resolve => {
        const modal = document.getElementById('dice-modal');
        const resultEl = document.getElementById('dice-result');
        const textEl = document.getElementById('dice-text');
        modal.style.display = 'block';
        let frames = 0;
        const anim = setInterval(() => {
            resultEl.textContent = Math.floor(Math.random() * 20) + 1;
            frames++;
            if (frames > 15) {
                clearInterval(anim);
                resultEl.textContent = roll;
                if (hit) {
                    resultEl.style.color = '#50fa7b';
                    textEl.textContent = `Target: ‚â§ ${threshold} | P < .05 (SIGNIFICANT!)`;
                } else {
                    resultEl.style.color = '#ff5555';
                    textEl.textContent = `Target: ‚â§ ${threshold} | P > .05 (TYPE II ERROR!)`;
                }
                setTimeout(() => {
                    modal.style.display = 'none';
                    resultEl.style.color = '#fff';
                    resolve();
                }, 1800);
            }
        }, 50);
    });
}

// ==================== TOOLTIPS ====================
function showCardTooltip(e, card) {
    const tip = document.getElementById('tooltip');
    if (card.isItem) {
        let rows = '';
        if (card.type === 'predictor' && TRUE_VALIDITY[card.constructId]) {
            rows = Object.keys(TRUE_VALIDITY[card.constructId]).map(o => {
                const v = TRUE_VALIDITY[card.constructId][o];
                const ai = getPairAdverseImpact(card.constructId, o);
                return `<tr><td style="padding:0.2vmin 0.4vmin;">${CONSTRUCTS[o]?.short||o}</td><td style="padding:0.2vmin 0.4vmin;">œÅ ${v.toFixed(2)}</td><td style="padding:0.2vmin 0.4vmin;">${ai.starsText}</td></tr>`;
            }).join('');
        } else if (card.type === 'outcome') {
            rows = Object.keys(TRUE_VALIDITY)
                .filter(p => TRUE_VALIDITY[p][card.constructId] !== undefined)
                .map(p => {
                    const v = TRUE_VALIDITY[p][card.constructId];
                    const ai = getPairAdverseImpact(p, card.constructId);
                    return `<tr><td style="padding:0.2vmin 0.4vmin;">${CONSTRUCTS[p]?.short||p}</td><td style="padding:0.2vmin 0.4vmin;">œÅ ${v.toFixed(2)}</td><td style="padding:0.2vmin 0.4vmin;">${ai.starsText}</td></tr>`;
                }).join('');
        }
        tip.innerHTML = `<div style="color:var(--gold);">${card.construct}</div><div>Item: ${card.indicator}</div><div>Avg rÃÑ = ${card.avgR.toFixed(2)}</div><hr style="border:0.1vmin solid #555; margin:0.5vmin 0;"><div style="color:var(--gold);">Validity | Fairness</div><table style="width:100%; font-size:0.8vmin; border-collapse:collapse;"><thead><tr><th align="left">Pair</th><th align="left">Validity</th><th align="left">Fairness</th></tr></thead><tbody>${rows}</tbody></table>`;
    } else {
        tip.innerHTML = `<div style="color:var(--gold);">${card.name}</div><div style="color:var(--gray);">${card.type.toUpperCase()}</div><div style="margin-top:0.5vmin;">${card.desc}</div>`;
    }
    positionTooltip(e, tip);
}
function showConstructTooltip(e, c) {
    const tip = document.getElementById('tooltip');
    const k = c.cards.length;
    const rel = spearmanBrown(k, c.cards[0].avgR);
    tip.innerHTML = `<div style="color:var(--gold);">${c.cards[0].construct}</div><div>Items: ${k}</div><div style="color:var(--green);">Reliability Œ± = ${rel.toFixed(3)}</div>`;
    positionTooltip(e, tip);
}
function showMonsterTooltip(e, m) {
    const tip = document.getElementById('tooltip');
    let pwrPercent = Math.floor(m.power * 100);
    let targetD20 = Math.max(1, Math.round(m.power * 20));
    const aiStars = m.adverseStarsText || '‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ';
    const jrText = m.requiresJobRelevance ? (m.hasJobRelevance ? 'Equipped' : 'Required to attack') : 'Not required';
    const correctionText = m.correctionApplied ? 'Applied (power uses corrected validity)' : 'Not applied';
    const imputationText = m.hasImputation ? 'Equipped' : 'Not equipped';
    tip.innerHTML = `<div style="color:var(--gold);">${m.name}</div><div style="color:#ff6644; font-size:1.5vmin;">ATK: ${m.atk}</div><hr style="border:0.1vmin solid #555; margin:0.5vmin 0;"><div style="display:grid; grid-template-columns:1fr 1fr; gap:0.8vmin;"><div><div style="color:var(--gold);">Validity</div><div style="color:var(--gray);">r_true (œÅ) = ${m.rTrue.toFixed(2)}</div><div style="color:var(--gray);">r_obs = ${m.rObs.toFixed(3)}</div><div style="color:var(--gray);">Correction: ${correctionText}</div></div><div><div style="color:var(--gold);">Fairness</div><div style="color:var(--gray);">Stars: ${aiStars}</div><div style="color:var(--gray);">Job Relevance: ${jrText}</div><div style="color:var(--gray);">Imputation: ${imputationText}</div></div></div><hr style="border:0.1vmin solid #555; margin:0.5vmin 0;"><div style="color:var(--resource);">Sample Size (N) = ${m.n}</div><div style="color:var(--green);">Power (1-Œ≤) = ${pwrPercent}%</div><div style="color:var(--white); font-size:0.8vmin;">Needs ‚â§ ${targetD20} on D20 to Hit</div>`;
    positionTooltip(e, tip);
}
function positionTooltip(e, tip) {
    tip.classList.add('active');
    const rect = tip.getBoundingClientRect();
    let x = e.clientX + 15, y = e.clientY + 15;
    if (x + rect.width > window.innerWidth) x = e.clientX - rect.width - 15;
    if (y + rect.height > window.innerHeight) y = e.clientY - rect.height - 15;
    tip.style.left = x + 'px'; tip.style.top = y + 'px';
}
function hideTooltip() { document.getElementById('tooltip').classList.remove('active'); }

// ==================== ACTIONS ====================
function clearSlotHighlights() {
    for (let i = 0; i < 3; i++) {
        document.getElementById(`player-construct-${i}`).classList.remove('highlight', 'spell-target', 'resource-target');
        document.getElementById(`opp-construct-${i}`).classList.remove('spell-target', 'resource-target');
        document.getElementById(`player-monster-${i}`).classList.remove('spell-target', 'resource-target');
        document.getElementById(`opp-monster-${i}`).classList.remove('attack-target', 'spell-target');
    }
}

function cancelAction() {
    if (isMulliganPending()) return;
    uiPhase = 'idle';
    selectedHandCard = null;
    attackingMonsterSlot = null;
    clearSlotHighlights();
    renderAll();
}

function selectHandCard(idx) {
    if (isMulliganPending()) return;
    if (!gs?.is_my_turn || gameOver || uiPhase.startsWith('attack') || uiPhase.startsWith('summon')) return;
    if (selectedHandCard === idx) { cancelAction(); return; }

    selectedHandCard = idx;
    const card = gs.my_hand[idx];
    clearSlotHighlights();

    if (card.isItem) {
        uiPhase = 'place';
        for (let i = 0; i < 3; i++) {
            const existing = gs.my_constructs[i];
            if (!existing || (existing.constructId === card.constructId && existing.cards.length < 3)) {
                document.getElementById(`player-construct-${i}`).classList.add('highlight');
            }
        }
    } else {
        if (card.id === 'missing_data') {
            uiPhase = 'spell_target_missing_data';
        } else if (card.id === 'range_restrict') {
            uiPhase = 'spell_target_range';
        } else if (card.id === 'correction') {
            uiPhase = 'spell_target_correct';
        } else if (card.id === 'sample_size') {
            uiPhase = 'spell_target_sample_size';
        } else if (card.id === 'job_relevance') {
            uiPhase = 'spell_target_job_relevance';
        } else if (card.id === 'imputation') {
            uiPhase = 'spell_target_imputation';
        } else if (card.id === 'p_hacking') {
            uiPhase = 'spell_target_p_hacking';
        } else if (card.id === 'practice_effect') {
            uiPhase = 'spell_target_practice_effect';
        } else if (card.id === 'bootstrapping') {
            uiPhase = 'spell_target_bootstrapping';
        } else if (card.id === 'item_analysis') {
            uiPhase = 'spell_target_item_analysis';
        } else if (card.id === 'construct_drift') {
            uiPhase = 'spell_target_construct_drift';
        } else if (card.id === 'criterion_contam') {
            uiPhase = 'spell_target_criterion_contam';
        }
    }
    renderAll();
}

// --- Construct placement ---
async function onConstructSlotClick(slotIdx) {
    if (isMulliganPending()) return;
    if (!gs?.is_my_turn || gameOver) return;

    if (uiPhase === 'summon_select_pred') {
        if (gs.my_constructs[slotIdx]?.type === 'predictor') {
            summonPredSlot = slotIdx;
            uiPhase = 'summon_select_out';
            clearSlotHighlights();
            for (let i = 0; i < 3; i++) {
                if (gs.my_constructs[i]?.type === 'outcome' && i !== summonPredSlot) {
                    document.getElementById(`player-construct-${i}`).classList.add('highlight');
                }
            }
            renderAll();
        }
        return;
    }
    if (uiPhase === 'summon_select_out') {
        if (slotIdx === summonPredSlot) return;
        if (gs.my_constructs[slotIdx]?.type === 'outcome') {
            await submitMove({ type: 'summon', pred_slot: summonPredSlot, out_slot: slotIdx });
            uiPhase = 'idle';
            summonPredSlot = null;
            clearSlotHighlights();
        }
        return;
    }

    if (uiPhase !== 'place' || selectedHandCard === null) return;
    const card = gs.my_hand[selectedHandCard];
    if (!card.isItem) return;

    const existing = gs.my_constructs[slotIdx];
    if (existing && existing.constructId !== card.constructId) return;
    if (existing && existing.cards.length >= 3) return;

    await submitMove({ type: 'place_card', hand_index: selectedHandCard, slot: slotIdx });
    selectedHandCard = null;
    uiPhase = 'idle';
    clearSlotHighlights();
}

// --- Summon ---
function startSummon() {
    if (isMulliganPending()) return;
    if (!gs?.is_my_turn || gs.my_summoned) return;
    selectedHandCard = null;
    uiPhase = 'summon_select_pred';
    clearSlotHighlights();
    for (let i = 0; i < 3; i++) if (gs.my_constructs[i]?.type === 'predictor') document.getElementById(`player-construct-${i}`).classList.add('highlight');
    renderAll();
}

// --- Spells ---
async function executeMissingData(slotIdx, owner, targetType) {
    if (uiPhase !== 'spell_target_missing_data') return;
    await submitMove({
        type: 'play_spell', hand_index: selectedHandCard,
        target_owner: owner === 'player' ? 'me' : 'opp',
        target_type: targetType === 'construct' ? 'construct' : 'monster',
        target_slot: slotIdx
    });
    triggerFlash('heal');
    selectedHandCard = null; uiPhase = 'idle'; clearSlotHighlights();
}

async function executeRangeRestrict(slotIdx) {
    if (uiPhase !== 'spell_target_range') return;
    await submitMove({ type: 'play_spell', hand_index: selectedHandCard, target_owner: 'opp', target_type: 'monster', target_slot: slotIdx });
    triggerFlash('heal');
    selectedHandCard = null; uiPhase = 'idle'; clearSlotHighlights();
}

async function executeCorrection(slotIdx) {
    if (uiPhase !== 'spell_target_correct') return;
    await submitMove({ type: 'play_spell', hand_index: selectedHandCard, target_owner: 'me', target_type: 'monster', target_slot: slotIdx });
    triggerFlash('heal');
    selectedHandCard = null; uiPhase = 'idle'; clearSlotHighlights();
}

async function executeSampleSize(slotIdx) {
    if (uiPhase !== 'spell_target_sample_size') return;
    await submitMove({ type: 'play_spell', hand_index: selectedHandCard, target_owner: 'me', target_type: 'monster', target_slot: slotIdx });
    triggerFlash('heal');
    selectedHandCard = null; uiPhase = 'idle'; clearSlotHighlights();
}

async function executeJobRelevance(slotIdx) {
    if (uiPhase !== 'spell_target_job_relevance') return;
    await submitMove({ type: 'play_spell', hand_index: selectedHandCard, target_owner: 'me', target_type: 'monster', target_slot: slotIdx });
    triggerFlash('heal');
    selectedHandCard = null; uiPhase = 'idle'; clearSlotHighlights();
}

async function executeImputation(slotIdx) {
    if (uiPhase !== 'spell_target_imputation') return;
    await submitMove({ type: 'play_spell', hand_index: selectedHandCard, target_owner: 'me', target_type: 'monster', target_slot: slotIdx });
    triggerFlash('heal');
    selectedHandCard = null; uiPhase = 'idle'; clearSlotHighlights();
}

async function executePHacking(slotIdx) {
    if (uiPhase !== 'spell_target_p_hacking') return;
    await submitMove({ type: 'play_spell', hand_index: selectedHandCard, target_owner: 'me', target_type: 'monster', target_slot: slotIdx });
    triggerFlash('heal');
    selectedHandCard = null; uiPhase = 'idle'; clearSlotHighlights();
}


async function executePracticeEffect(slotIdx, targetOwner = 'me') {
    if (uiPhase !== 'spell_target_practice_effect') return;
    await submitMove({ type: 'play_spell', hand_index: selectedHandCard, target_owner: targetOwner, target_type: 'monster', target_slot: slotIdx });
    triggerFlash('heal');
    selectedHandCard = null; uiPhase = 'idle'; clearSlotHighlights();
}

async function executeBootstrapping(slotIdx) {
    if (uiPhase !== 'spell_target_bootstrapping') return;
    await submitMove({ type: 'play_spell', hand_index: selectedHandCard, target_owner: 'me', target_type: 'monster', target_slot: slotIdx });
    triggerFlash('heal');
    selectedHandCard = null; uiPhase = 'idle'; clearSlotHighlights();
}

async function executeItemAnalysis(slotIdx) {
    if (uiPhase !== 'spell_target_item_analysis') return;
    await submitMove({ type: 'play_spell', hand_index: selectedHandCard, target_owner: 'me', target_type: 'construct', target_slot: slotIdx });
    triggerFlash('heal');
    selectedHandCard = null; uiPhase = 'idle'; clearSlotHighlights();
}

async function executeConstructDrift(slotIdx) {
    if (uiPhase !== 'spell_target_construct_drift') return;
    await submitMove({ type: 'play_spell', hand_index: selectedHandCard, target_owner: 'opp', target_type: 'construct', target_slot: slotIdx });
    triggerFlash('heal');
    selectedHandCard = null; uiPhase = 'idle'; clearSlotHighlights();
}

async function executeCriterionContam(slotIdx) {
    if (uiPhase !== 'spell_target_criterion_contam') return;
    await submitMove({ type: 'play_spell', hand_index: selectedHandCard, target_owner: 'opp', target_type: 'monster', target_slot: slotIdx });
    triggerFlash('heal');
    selectedHandCard = null; uiPhase = 'idle'; clearSlotHighlights();
}

function onMonsterSlotClick(slotIdx) {
    if (isMulliganPending()) return;
    if (uiPhase === 'spell_target_correct') executeCorrection(slotIdx);
    if (uiPhase === 'spell_target_sample_size') executeSampleSize(slotIdx);
    if (uiPhase === 'spell_target_job_relevance') executeJobRelevance(slotIdx);
    if (uiPhase === 'spell_target_imputation') executeImputation(slotIdx);
    if (uiPhase === 'spell_target_p_hacking') executePHacking(slotIdx);
    if (uiPhase === 'spell_target_practice_effect') executePracticeEffect(slotIdx, 'me');
    if (uiPhase === 'spell_target_bootstrapping') executeBootstrapping(slotIdx);
}

// --- Attack ---
function startAttack() {
    if (isMulliganPending()) return;
    if (!gs?.is_my_turn || gameOver) return;
    selectedHandCard = null;
    uiPhase = 'attack_select_monster';
    renderAll();
}

function selectAttackingMonster(slotIdx) {
    if (isMulliganPending()) return;
    const m = gs.my_monsters[slotIdx];
    if (!canMonsterAttack(m)) return;
    attackingMonsterSlot = slotIdx;

    if (gs.opp_monsters.some(m => m !== null)) {
        uiPhase = 'attack_select_target';
        renderAll();
    } else {
        executeAttack('lp', null);
    }
}

async function selectAttackTarget(type, targetSlot) {
    if (isMulliganPending()) return;
    await executeAttack(type, targetSlot);
}

async function executeAttack(targetType, targetSlot) {
    uiPhase = 'rolling';
    clearSlotHighlights();
    renderAll();

    clearInterval(session.pollTimer);

    const res = await submitMove({
        type: 'attack',
        attacker_slot: attackingMonsterSlot,
        target_type: targetType,
        target_slot: targetSlot
    }, true);

    if (res.move_result) {
        const mr = res.move_result;

        await showDiceRoll(mr.roll, mr.threshold, mr.hit);

        if (res.state) {
            gs = res.state;
            if (gs.log && gs.log.length > lastLogCount) {
                for (let i = lastLogCount; i < gs.log.length; i++) {
                    addLog(gs.log[i].msg, gs.log[i].type);
                }
                lastLogCount = gs.log.length;
            }
        }

        if (mr.hit) {
            triggerScreenShake();
            triggerFlash('attack');
            if (mr.attack_data?.damage) {
                const targetIsOpp = mr.attack_data.outcome !== 'lose';
                showDamageNumber(targetIsOpp ? 'opp-lp' : 'player-lp', mr.attack_data.damage);
            }
        } else {
            triggerFlash('error');
        }

        renderAll();

        if (gs.status === 'finished' && !gameOver) {
            gameOver = true;
            endGame(gs.i_won);
        }
    }

    attackingMonsterSlot = null;
    uiPhase = 'idle';
    clearSlotHighlights();

    if (!gameOver) {
        session.pollTimer = setInterval(pollNow, 2000);
    }
}

// --- Meta ---
async function doMeta() {
    if (isMulliganPending()) return;
    uiPhase = 'idle';
    const res = await submitMove({ type: 'meta' });
    if (res.move_result?.meta) {
        triggerScreenShake();
        triggerFlash('meta');
    }
    clearSlotHighlights();
}

// --- End Turn ---
async function doEndTurn() {
    if (isMulliganPending()) return;
    if (!gs?.is_my_turn) return;
    uiPhase = 'idle';
    selectedHandCard = null;
    clearSlotHighlights();
    await submitMove({ type: 'end_turn' });
}

// ==================== END GAME ====================
function endGame(playerWon) {
    gameOver = true;
    clearInterval(session.pollTimer);
    document.getElementById('end-screen').classList.add('active');
    document.getElementById('end-title').innerHTML = playerWon
        ? '<span style="color:var(--gold)">VICTORY!</span>'
        : '<span style="color:var(--outcome-light)">DEFEAT!</span>';
    document.getElementById('end-message').textContent = playerWon
        ? "Your highly reliable measures captured true validity!"
        : "Measurement error attenuated your validity into oblivion.";
}

function showTutorial() { document.getElementById('tutorial-modal').classList.add('active'); }
function closeTutorial() { document.getElementById('tutorial-modal').classList.remove('active'); }

showMenu('main');
updateAIDifficultyUI();
</script>
</body>
</html>
